"use strict";(self.webpackChunkcpp_lang_net=self.webpackChunkcpp_lang_net||[]).push([[79641],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=u(n),h=o,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||i;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var u=2;u<i;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},31929:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>u,default:()=>m,frontMatter:()=>l,metadata:()=>c,toc:()=>p});var a=n(87462),o=(n(67294),n(3905)),i=n(22307),s=n(74866),r=n(85162);const l={title:"Conditions \xbb Tips and style",description:"Lesson: tips and style on conditions in C++",tags:["condition","if","else","else-if","compound","bool","boolean","tips","style"],hide_title:!0},u="Conditions \xbb Tips and style",c={unversionedId:"course/basics/conditions/tips",id:"course/basics/conditions/tips",title:"Conditions \xbb Tips and style",description:"Lesson: tips and style on conditions in C++",source:"@site/content/learn/course/basics/conditions/tips.mdx",sourceDirName:"course/basics/conditions",slug:"/course/basics/conditions/tips",permalink:"/CppLangNet/learn/course/basics/conditions/tips",draft:!1,editUrl:"https://github.com/Cpp4You/CppLangNet/edit/main/content/learn/course/basics/conditions/tips.mdx",tags:[{label:"condition",permalink:"/CppLangNet/learn/tags/condition"},{label:"if",permalink:"/CppLangNet/learn/tags/if"},{label:"else",permalink:"/CppLangNet/learn/tags/else"},{label:"else-if",permalink:"/CppLangNet/learn/tags/else-if"},{label:"compound",permalink:"/CppLangNet/learn/tags/compound"},{label:"bool",permalink:"/CppLangNet/learn/tags/bool"},{label:"boolean",permalink:"/CppLangNet/learn/tags/boolean"},{label:"tips",permalink:"/CppLangNet/learn/tags/tips"},{label:"style",permalink:"/CppLangNet/learn/tags/style"}],version:"current",frontMatter:{title:"Conditions \xbb Tips and style",description:"Lesson: tips and style on conditions in C++",tags:["condition","if","else","else-if","compound","bool","boolean","tips","style"],hide_title:!0},sidebar:"defaultSidebar",previous:{title:"Booleans",permalink:"/CppLangNet/learn/course/basics/conditions/booleans"},next:{title:"Conditions \xbb Examples",permalink:"/CppLangNet/learn/course/basics/conditions/examples"}},d={},p=[{value:"Always include the curly brackets",id:"always-include-the-curly-brackets",level:2},{value:"Keep bracket style consistent",id:"keep-bracket-style-consistent",level:2},{value:"Pros",id:"pros",level:4},{value:"Cons",id:"cons",level:4},{value:"Pros",id:"pros-1",level:4},{value:"Cons",id:"cons-1",level:4},{value:"Keep indentation consistent",id:"keep-indentation-consistent",level:2},{value:"Avoid complicated boolean expressions",id:"avoid-complicated-boolean-expressions",level:2},{value:"Avoid deep nesting of conditions",id:"avoid-deep-nesting-of-conditions",level:2}],h={toc:p};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"conditions--tips-and-style"},"Conditions \xbb Tips and style"),(0,o.kt)("p",null,"This article is simply an unordered collection of tips and tricks to help you improve\nhow you write your conditional code. If you have been following this course in order,\nmany of the concepts used here have not been covered yet. Do not worry if you don't\nunderstand some of the stuff in this article, they will come in later lessons."),(0,o.kt)("h2",{id:"always-include-the-curly-brackets"},"Always include the curly brackets"),(0,o.kt)("p",null,"Most C++ constructs you may come across actually have ",(0,o.kt)("strong",{parentName:"p"},"optional curly brackets"),".\nIf you omit the curly brackets, then it is assumed the next line of code is in the\nbody of the if statement, and anything else after that is outside of the if statement."),(0,o.kt)("p",null,"This can sometimes make for shorter, slightly easier to read code. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83d\udd39 Omitting the curly brackets"',title:'"\ud83d\udd39',Omitting:!0,the:!0,curly:!0,'brackets"':!0},'if (A and B)\n    std::cout << "They\'re both true!\\n";\n\nstd::cout << "Goodbye!";\n')),(0,o.kt)("p",null,"However, this is a very common beginner trap as this can quickly lead to the wrong behavior.\nEspecially upon editing the code, it is common to accidentally forget to add the braces\nwhen expanding the if statement body.\nRemember, C++ does not care about whitespace or indentation,\nso if you try to do:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\u26a0\ufe0f Misleading indentation"',title:'"\u26a0\ufe0f',Misleading:!0,'indentation"':!0},'if (A and B)\n    std::cout << "They\'re both true!\\n";\n    // warning-next-line\n    std::cout << "That\'s cool that they are both true.\\n";\n\nstd::cout << "Goodbye!";\n')),(0,o.kt)("p",null,"The highlighted line will ",(0,o.kt)("strong",{parentName:"p"},"always be run"),", as it is not a part of the if statement.\nIt is equivalent to putting the curly braces only after the line that immediately follows\nthe if statement. Due to the frequency that beginners get bitten by this mistake,\nit is recommended to always put braces on your if statements.\nMistakes like this have even caused caused ",(0,o.kt)("a",{parentName:"p",href:"https://nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch/"},"major security vulnerabilities in\nreal-world codebases"),"."),(0,o.kt)("h2",{id:"keep-bracket-style-consistent"},"Keep bracket style consistent"),(0,o.kt)("p",null,'More on the topic of curly brackets... spending any amount of time in online programming communities\nwill probably expose you to the long-fought battle between "inline" vs "new-line" braces.\nThis is the debate that centers on the very cosmetic decision of whether you should put opening\ncurly brackets ',(0,o.kt)("inlineCode",{parentName:"p"},"{")," on the same line as if statements, functions, loops, etc., or if it should be\non a new line. The two styles and pros/cons are illustrated below:"),(0,o.kt)(s.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"inline",label:"\ud83d\udd37 Inline braces",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'int main() {\n\n    int x = 10;\n\n    if (x == 10) {\n        std::cout << "X is 10!";\n    } else {\n        std::cout << "X is not 10!";\n    }\n\n\n\n\n    for (int i = 0; i < 5; i++) {\n        std::cout << "i: " << i << "\\n";\n    }\n}\n\n')),(0,o.kt)(i.Z,{columns:["1fr","1fr"],mdxType:"Columns"},(0,o.kt)("div",null,(0,o.kt)("h4",{id:"pros"},"Pros"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Code is more compact"),(0,o.kt)("li",{parentName:"ul"},"Organization via empty lines is easier"))),(0,o.kt)("div",null,(0,o.kt)("h4",{id:"cons"},"Cons"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Opening and closing braces do not line up"),(0,o.kt)("li",{parentName:"ul"},"Too dense for some people"),(0,o.kt)("li",{parentName:"ul"},"Can become messy under some formatting styles")))),(0,o.kt)("p",null,"Note that this example was spaced out with extra empty lines to make it line up with the next example.\nThese extra lines are not relevant to the comparison of brace styles.")),(0,o.kt)(r.Z,{value:"newline",label:"\ud83d\udd36 New-line braces",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'int main()\n{\n    int x = 10;\n\n    if (x == 10)\n    {\n        std::cout << "X is 10!";\n    }\n    else\n    {\n        std::cout << "X is not 10!";\n    }\n\n    for (int i = 0; i < 5; i++)\n    {\n        std::cout << "i: " << i << "\\n";\n    }\n}\n')),(0,o.kt)(i.Z,{columns:["1fr","1fr"],mdxType:"Columns"},(0,o.kt)("div",null,(0,o.kt)("h4",{id:"pros-1"},"Pros"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Opening and closing braces line up"),(0,o.kt)("li",{parentName:"ul"},"Easier to read for some people"),(0,o.kt)("li",{parentName:"ul"},"More consistent formatting under some styles"))),(0,o.kt)("div",null,(0,o.kt)("h4",{id:"cons-1"},"Cons"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Spaces out code significantly"),(0,o.kt)("li",{parentName:"ul"},"Wastes vertical space")))))),(0,o.kt)("p",null,"Ultimately, it is up to you what style you stick with.\nThere is roughly an even split between the popularity of the two choices.\nThe main takeaway is that you should only use one style per project.\n",(0,o.kt)("strong",{parentName:"p"},"Do not mix styles within the same code.")),(0,o.kt)("p",null,"However, don't get too attached to one style. Once you find a professional\nprogramming job, you will be expected to keep with the style that already\nexists at that company.\nConsistent code is more important than your own personal preferences!"),(0,o.kt)("h2",{id:"keep-indentation-consistent"},"Keep indentation consistent"),(0,o.kt)("p",null,"One of the most common gripes with advanced programmers helping beginners is that\ntheir code is super messy! This makes it difficult to read and even harder if you're\ntrying to help them figure out errors. One of the best ways to make your code cleaner\nand easier to understand is by keeping your indentation consistent. Thankfully, this is very easy."),(0,o.kt)("p",null,"Every time you enter a ",(0,o.kt)("em",{parentName:"p"},"scope"),', you should indent your code one more level with the tab key.\nEvery time you exit a scope, you should unindent one level. A scope is basically one "block"\nof C++. Inside a function is a single scope, inside an if statement is a single scope, inside\na for loop is a single scope, etc. Below are examples of what good and bad indentation looks like.'),(0,o.kt)(s.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"good",label:"\u2714\ufe0f Good Indentation",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'// The parts of the functions are always unindented\n// While immediately inside the function, it is indented at one level\nbool checkValue(int x) {\n    // The parts of the if statement are indented one level \n    // because it is immediately inside the function\n    if (x < 50) {\n        // Inside the if statement, we indent another level\n        return true;\n    } else {\n        return false;\n    } // The braces line up with what started the scope\n}\n\nint main() {\n    // Everything in the root scope of the function is indented one level\n    int value;\n    std::cin >> value;\n\n    // The outer parts of this while loop are indented one level\n    while (true) {\n        // Inside the while loop, we indent another level\n        if (checkValue(value)) {\n            // Inside another scope, so we indent a third level\n            std::cout << "You have entered a good value.\\n";\n            break;\n        }\n\n        // We drop one indent level after exiting the if statement scope\n        std::cout << "You have entered a bad value.\\n";\n        std::cout << "Try again.\\n";\n    } // This brace lines up with the while loop that started this scope\n\n    // We return to a single level of indentation after exiting the while loop scope\n    std::cout << "Goodbye!";\n} // This brace lines up with the beginning of the function\n'))),(0,o.kt)(r.Z,{value:"bad",label:"\u274c Bad Indentation",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'\n\nbool checkValue(int x) {\n\n// This if statement should be indentented one\nif (x < 50) {\nreturn true; // This line is missing two indentations\n        } else { \n                return false; // The indentation here is obviously not consistent\n}} // These braces should be on their own lines and properly indented\n\n\n    // The function is indented too far over\n    int main() {\n\n    int value; \n        std::cin >> value; // The indentation here is not consistent for the same scope\n\n\n    while (true) {\n    // This if statement is missing an indentation level\n    if (checkValue(value)) {\n        std::cout << "You have entered a good value.\\n"; break; // Don\'t put two things on one line\n        } // This brace does not line up with what created it\n\n\n\n// These lines are not indented\nstd::cout << "You have entered a bad value.\\n";\nstd::cout << "Try again.\\n";\n} // This brace does not line up with the while loop that created it\n\n            // This line is not consistent with the rest of the indentation in this scope\n            std::cout << "Goodbye!";\n}\n')))),(0,o.kt)("p",null,'You can see how all of the code in the first example is neatly aligned. We follow consistent rules of\nwhen to indent based off how deep of a scope we are in. Each level of nesting\na scope warrants an extra level of indentation. Additionally, all of our braces\nare lined up with the parent that "started" the scope, which makes it easy to find\nwhat construct a brace belongs to.'),(0,o.kt)("p",null,"On the other hand, the code in the second example is significantly more confusing and frustrating to read.\nIt's very difficult to find what code belongs to what scope, where scopes end, and what should be executed when.\nAdditionally, it's just generally very messy to read and is a pain to try to look through."),(0,o.kt)("p",null,"It may seem like extra work to keep indentation clean and consistent,\nespecially if you are making changes to existing code.\nBut, follow these guidelines and I promise that you will thank yourself later.\nIt is far too common for beginners to be misled by poor indentation,\nand fixing it at the source is the best way to prevent this."),(0,o.kt)("p",null,"If you find dealing with indentation to be difficult, consider using hotkeys to your advantage.\nIn most code editors, you can indent multiple lines at once by selecting what you want to indent and pressing the ",(0,o.kt)("inlineCode",{parentName:"p"},"Tab")," key.\nConversely, you can unindent multiple lines at once with ",(0,o.kt)("inlineCode",{parentName:"p"},"Shift+Tab"),"."),(0,o.kt)("h2",{id:"avoid-complicated-boolean-expressions"},"Avoid complicated boolean expressions"),(0,o.kt)("p",null,"If you're trying to build a condition that requires the validation of multiple boolean expressions,\nit can be very easy to make confusing code by using too many ",(0,o.kt)("inlineCode",{parentName:"p"},"and"),"'s, ",(0,o.kt)("inlineCode",{parentName:"p"},"or"),"'s, and ",(0,o.kt)("inlineCode",{parentName:"p"},"not"),"'s.\nThe best way to prevent this is to make a ",(0,o.kt)("inlineCode",{parentName:"p"},"bool")," returning function that computes this\ncomplicated expression for you. That way, the code becomes more readable and more maintainable.\nYou may also find the methods from the next section to be helpful."),(0,o.kt)("h2",{id:"avoid-deep-nesting-of-conditions"},"Avoid deep nesting of conditions"),(0,o.kt)("p",null,"It is very easy to make complicated logic with if statements, especially if you\nexcessively nest them inside of each other. For example, try to figure out\nwhat the following snippet actually does:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\u26a0\ufe0f Confusing if statements"',title:'"\u26a0\ufe0f',Confusing:!0,if:!0,'statements"':!0},'if (A or B) {\n    if (not B and C) {\n        if (A or D) {\n            if (A and not B) {\n                std::cout << "Hello!";\n            } else {\n                std::cout << "Will this line ever be run?";\n            }\n        } else if (not D) {\n            std::cout << "What about this one?";\n        }\n    } else {\n        std::cout << "It\'s starting to get pretty weird now...";\n    }\n} else if (B) {\n    std::cout << "I don\'t think this one will ever run.";\n} else if (not A and not b) {\n    std::cout << "Surely, this one will be called eventually.";\n} else {\n    std::cout << "Goodbye!";\n}\n')),(0,o.kt)("p",null,"It may take you several minutes to figure out under what cases each of\nthese print statements activates, especially if you're working in\nlarge and potentially very complicated code bases."),(0,o.kt)("p",null,"There are two good ways to improve this. First, you can break out\nthe inner nested conditions into their own ",(0,o.kt)("a",{parentName:"p",href:"/learn/course/basics/functions/"},"functions"),".\nThat way, the complexity gets hidden away behind a layer of ",(0,o.kt)("em",{parentName:"p"},"abstraction"),", and you are\nforced to create a descriptive name for each function you create."),(0,o.kt)("p",null,'The second method applies if you have a clear "happy path" and "sad path".\nYou can reorganize the if statements such that the happy path is the least indented, and\nthe sad path escapes early. Study this example to see what this may look like:'),(0,o.kt)(s.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"good",label:"\u2714\ufe0f Good if statements",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'using std::string;\n\nstring loginAsAdmin(string user, string pass) {\n    if (not doesUserExist(user)) {\n        return "User does not exist";\n    }\n\n    if (not isPasswordCorrect(user, pass)) {\n        return "Password is incorrect";\n    }\n    \n    if (not tryLogin(user, pass)) {\n        return "Failed to login";\n    }\n\n    if (not isAdmin(user)) {\n        return "User is not admin";\n    }\n\n    return "Success";\n}\n'))),(0,o.kt)(r.Z,{value:"bad",label:"\u26a0\ufe0f Confusing if statements",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'using std::string;\n\nstring loginAsAdmin(string user, string pass) {\n    if (doesUserExist(user)) {\n        if (isPasswordCorrect(user, pass)) {\n            if (tryLogin(user, pass)) {\n                if (isAdmin(user)) {\n                    return "Success";\n                } else {\n                    return "User is not admin";\n                }\n            } else {\n                return "Failed to login";\n            }\n        } else {\n            return "Password is incorrect";\n        }\n    } else {\n        return "User does not exist";\n    }\n}\n')))),(0,o.kt)("p",null,"You can see how the confusing example has a tell-tale triangular shape.\nThis is a very common indicator that you are nesting your logic too deep,\nand you should apply one of the two clean-up methods to fix it. Here,\nwe inverted the conditions to check the sad path first. The happy path\ncontinues at the bottom once we have passed all of the checks."))}m.isMDXComponent=!0},85162:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(67294),o=n(86010);const i="tabItem_Ymn6";function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(i,s),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>T});var a=n(87462),o=n(67294),i=n(86010),s=n(12466),r=n(76775),l=n(91980),u=n(67392),c=n(50012);function d(e){return function(e){return o.Children.map(e,(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:o}}=e;return{value:t,label:n,attributes:a,default:o}}))}function p(e){const{values:t,children:n}=e;return(0,o.useMemo)((()=>{const e=t??d(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function h(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const a=(0,r.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(i),(0,o.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(a.location.search);t.set(i,e),a.replace({...a.location,search:t.toString()})}),[i,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,i=p(e),[s,r]=(0,o.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[l,u]=m({queryString:n,groupId:a}),[d,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,i]=(0,c.Nk)(n);return[a,(0,o.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:a}),y=(()=>{const e=l??d;return h({value:e,tabValues:i})?e:null})();(0,o.useLayoutEffect)((()=>{y&&r(y)}),[y]);return{selectedValue:s,selectValue:(0,o.useCallback)((e=>{if(!h({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);r(e),u(e),f(e)}),[u,f,i]),tabValues:i}}var y=n(72389);const b="tabList__CuJ",g="tabItem_LNqP";function k(e){let{className:t,block:n,selectedValue:r,selectValue:l,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),p=e=>{const t=e.currentTarget,n=c.indexOf(t),a=u[n].value;a!==r&&(d(t),l(a))},h=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:s}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,key:t,ref:e=>c.push(e),onKeyDown:h,onClick:p},s,{className:(0,i.Z)("tabs__item",g,s?.className,{"tabs__item--active":r===t})}),n??t)})))}function v(e){let{lazy:t,children:n,selectedValue:a}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===a));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},i.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function w(e){const t=f(e);return o.createElement("div",{className:(0,i.Z)("tabs-container",b)},o.createElement(k,(0,a.Z)({},e,t)),o.createElement(v,(0,a.Z)({},e,t)))}function T(e){const t=(0,y.Z)();return o.createElement(w,(0,a.Z)({key:String(t)},e))}},22307:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(87462),o=n(67294);const i="columns_Terr";function s(e){const t=e.style||{};t.gap=e.spacing||20,e.columns?t.gridTemplateColumns=e.columns.map((e=>`${e}`)).join(" "):t.gridTemplateColumns="repeat(2, 1fr)";const n={...e};return delete n.columns,delete n.spacing,delete n.breakAt,o.createElement("div",(0,a.Z)({className:i,"data-break-at":e.breakAt??"md"},n,{style:t}),e.children)}s.isMDXComponent=!0}}]);