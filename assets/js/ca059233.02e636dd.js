"use strict";(self.webpackChunkcpp_lang_net=self.webpackChunkcpp_lang_net||[]).push([[58308,20351,42971],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,l=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=u(n),m=o,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||l;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=n.length,i=new Array(l);i[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:o,i[1]=r;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},96214:(e,t,n)=>{var a=n(64836);t.Z=void 0;var o=a(n(64938)),l=n(85893),i=(0,o.default)((0,l.jsx)("path",{d:"M9.4 16.6 4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0 4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"}),"Code");t.Z=i},95175:(e,t,n)=>{var a=n(64836);t.Z=void 0;var o=a(n(64938)),l=n(85893),i=(0,o.default)((0,l.jsx)("path",{d:"m4 18 8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"}),"FastForward");t.Z=i},71498:(e,t,n)=>{var a=n(64836);t.Z=void 0;var o=a(n(64938)),l=n(85893),i=(0,o.default)((0,l.jsx)("path",{d:"M11 18V6l-8.5 6 8.5 6zm.5-6 8.5 6V6l-8.5 6z"}),"FastRewind");t.Z=i},94265:(e,t,n)=>{var a=n(64836);t.Z=void 0;var o=a(n(64938)),l=n(85893),i=(0,o.default)([(0,l.jsx)("path",{d:"M14 14v1.17L17.17 12 14 8.83V10H6v4z",opacity:".3"},"0"),(0,l.jsx)("path",{d:"m20 12-8-8v4H4v8h8v4l8-8zM6 14v-4h8V8.83L17.17 12 14 15.17V14H6z"},"1")],"ForwardTwoTone");t.Z=i},53247:(e,t,n)=>{var a=n(64836);t.Z=void 0;var o=a(n(64938)),l=n(85893),i=(0,o.default)((0,l.jsx)("path",{d:"M6 19h4V5H6v14zm8-14v14h4V5h-4z"}),"Pause");t.Z=i},70655:(e,t,n)=>{var a=n(64836);t.Z=void 0;var o=a(n(64938)),l=n(85893),i=(0,o.default)((0,l.jsx)("path",{d:"M8 5v14l11-7z"}),"PlayArrow");t.Z=i},94229:(e,t,n)=>{var a=n(64836);t.Z=void 0;var o=a(n(64938)),l=n(85893),i=(0,o.default)((0,l.jsx)("path",{d:"M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"}),"Settings");t.Z=i},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),o=n(86010);const l="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(l,i),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>N});var a=n(87462),o=n(67294),l=n(86010),i=n(12466),r=n(76775),s=n(91980),u=n(67392),c=n(50012);function p(e){return function(e){return o.Children.map(e,(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:o}}=e;return{value:t,label:n,attributes:a,default:o}}))}function d(e){const{values:t,children:n}=e;return(0,o.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,r.k6)(),l=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s._X)(l),(0,o.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(a.location.search);t.set(l,e),a.replace({...a.location,search:t.toString()})}),[l,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,l=d(e),[i,r]=(0,o.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:l}))),[s,u]=h({queryString:n,groupId:a}),[p,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,l]=(0,c.Nk)(n);return[a,(0,o.useCallback)((e=>{n&&l.set(e)}),[n,l])]}({groupId:a}),g=(()=>{const e=s??p;return m({value:e,tabValues:l})?e:null})();(0,o.useLayoutEffect)((()=>{g&&r(g)}),[g]);return{selectedValue:i,selectValue:(0,o.useCallback)((e=>{if(!m({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);r(e),u(e),f(e)}),[u,f,l]),tabValues:l}}var g=n(72389);const k="tabList__CuJ",b="tabItem_LNqP";function y(e){let{className:t,block:n,selectedValue:r,selectValue:s,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:p}=(0,i.o5)(),d=e=>{const t=e.currentTarget,n=c.indexOf(t),a=u[n].value;a!==r&&(p(t),s(a))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:i}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:d},i,{className:(0,l.Z)("tabs__item",b,i?.className,{"tabs__item--active":r===t})}),n??t)})))}function v(e){let{lazy:t,children:n,selectedValue:a}=e;const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===a));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function w(e){const t=f(e);return o.createElement("div",{className:(0,l.Z)("tabs-container",k)},o.createElement(y,(0,a.Z)({},e,t)),o.createElement(v,(0,a.Z)({},e,t)))}function N(e){const t=(0,g.Z)();return o.createElement(w,(0,a.Z)({key:String(t)},e))}},98839:(e,t,n)=>{n.d(t,{z:()=>a});const a=n(67294).createContext({name:"Unknown",folder:"unknown"})},18169:(e,t,n)=>{function a(e){return"object"!=typeof e?"default":"highlight"===e.kind?e.variant:"default"}function o(e){return"object"!=typeof e?e:"highlight"===e.kind?e.content:e}function l(e,t){return{kind:"highlight",variant:t??"default",content:e}}function i(e,t,n,a){return{kind:"block",startLine:e,endLine:t,startColumn:n,endColumn:a}}function r(e,t,n){return{kind:"range",startLine:e,endLine:e,startColumn:t,endColumn:n}}function s(e){const t=getComputedStyle(e),n=parseFloat(t.paddingLeft)+parseFloat(t.paddingRight),a=parseFloat(t.borderLeftWidth)+parseFloat(t.borderRightWidth);return e.offsetWidth-n-a}function u(e,t,n){const a=function(e,t){let n=0,a=null;return function o(l){if(l.nodeType!==Node.TEXT_NODE)for(let i=0;i<l.childNodes.length;i++){const r=l.childNodes[i];if(o(r),a)return;if(r.nodeType!==Node.ELEMENT_NODE)continue;const u=r;if(u.classList.contains("token-line")){if(n===t){const t=u.firstChild;let n=0;(t.nodeType!==Node.ELEMENT_NODE||!t.classList.contains("token"))&&(n=t.getBoundingClientRect().width+2);const o=u.getBoundingClientRect(),l=s(u);return e.getBoundingClientRect(),void(a={top:o.top,left:o.left+n,width:l-n,height:o.height})}++n}}}(e),a}(e,t);if(!a)return null;const o=n.getBoundingClientRect();return a.top-=o.top,a.left-=o.left,a}function c(e,t){return u(e,t,e)}function p(e,t){if("number"==typeof t){const n=c(e,t);if(!n)return null;const a=s(e);return{top:n.top,left:n.left,width:.8*a,height:n.height}}return"block"===t.kind?function(e,t){const n=c(e,t.startLine),a=c(e,t.endLine);if(!n||!a)return null;const o=.61*parseFloat(getComputedStyle(e).fontSize||"16"),l=s(e),i=n.left+t.startColumn*o,r=(t.endColumn-t.startColumn)*o;return{top:n.top,left:i,width:0===t.endColumn?l:r,height:a.top+a.height-n.top}}(e,t):function(e,t){let n=0,a=0,o=null,l=0,i=null,r=0;if(function e(s){if(s.nodeType===Node.TEXT_NODE){const e=s.textContent||"";for(let u=0;u<e.length;u++){if(n===t.startLine&&a===t.startColumn&&(o=s,l=u),o&&n===t.endLine&&a===t.endColumn)return i=s,void(r=u);a++}}else for(let t=0;t<s.childNodes.length;t++){const o=s.childNodes[t];if(e(o),o.classList&&o.classList.contains("token-line")&&(n++,a=0),i)return}}(e),!o||!i)return{top:0,left:0,width:0,height:0};const s=function(){const e=document.createRange();e.setStart(o,l),e.setEnd(i,r);const t=e.getBoundingClientRect();return{top:t.top,left:t.left,width:t.width,height:t.height}}(),u=e.getBoundingClientRect();return{top:s.top-u.top,left:s.left-u.left,width:s.width,height:s.height}}(e,t)}function d(e){return{...e}}n.d(t,{CE:()=>u,Je:()=>p,MU:()=>o,Pb:()=>i,Qb:()=>d,US:()=>a,_V:()=>l,r7:()=>r})},66830:(e,t,n)=>{n.d(t,{Z:()=>E});var a=n(67294),o=n(60614),l=n(96214),i=n(73935);function r(e){if(!e.container)return null;const[t,n]=a.useState(null);return(0,a.useEffect)((()=>{const t=setInterval((()=>{const a=e.getPortalTarget();a&&(n(a),clearInterval(t))}),200);return()=>clearInterval(t)}),[e.container]),function(e,t,n){const o=a.useRef((()=>{const e=document.createElement("div");if(n.style)for(const t in n.style)e.style[t]=n.style[t];return e})());return(0,a.useEffect)((()=>{if(t)return t.prepend(o.current),()=>{t.removeChild(o.current)}}),[t,o]),t?(0,i.createPortal)(e,o.current):null}(e.children,t,{style:e.portalStyle})}function s(e){return a.createElement("button",{style:{marginRight:5,cursor:"pointer"},title:"Show the full source",onClick:e.onClick},a.createElement(l.Z,{fontSize:"small"}))}function u(e){return a.createElement(r,{container:e.container,getPortalTarget:()=>e.container.querySelector("pre+div"),portalStyle:e.portalStyle},e.children)}const c=function(e){return a.createElement(u,{container:e.container},a.createElement(s,{onClick:e.onShowFullCode}))};var p=n(18169),d=n(93946),m=n(70655),h=n(53247),f=n(71498),g=n(95175),k=n(94229);function b(e){return a.createElement("div",{className:"insp-flow-control-buttons"},e.running&&a.createElement(d.Z,{title:"Pause",color:"success",onClick:e.onPause},a.createElement(h.Z,null)),!e.running&&a.createElement(a.Fragment,null,"(paused)\xa0",a.createElement(d.Z,{title:"Resume",color:"success",onClick:e.onResume},a.createElement(m.Z,null))),a.createElement(d.Z,{title:"Step Backward",color:"info",onClick:e.onStepBackward},a.createElement(f.Z,null)),a.createElement(d.Z,{title:"Step Forward",color:"info",onClick:e.onStepForward},a.createElement(g.Z,null)),a.createElement(d.Z,{title:"Settings",color:"inherit"},a.createElement(k.Z,null)),a.createElement("span",{style:{marginLeft:5}},"Step"),a.createElement("span",{style:{minWidth:30,textAlign:"right"}},e.currentStep||1),"\xa0of ",e.totalSteps||1)}var y=n(94265);const v=function(e){const t=e.variant??"default",n=e.lineBounds.top+e.lineBounds.height/2;return a.createElement("span",{key:e.key,"data-variant":t,className:"insp-code-arrow",style:{top:n,left:`calc(${e.lineBounds.left}px - 2rem)`}},a.createElement(y.Z,{color:"inherit",fontSize:"inherit"}))};const w=function(e){const t=e.variant??"default";return a.createElement("div",{key:e.key,className:"insp-block-highlight","data-variant":t,style:{top:e.bounds.top-2,left:e.bounds.left-2,width:`calc(min(${e.bounds.width+4}px, 80vw))`,height:e.bounds.height+4}})};function N(e){return a.createElement(r,{container:e.container,getPortalTarget:()=>e.container.querySelector("pre>code"),portalStyle:e.portalStyle},e.children)}function _(e){return a.createElement(r,{container:e.container,getPortalTarget:()=>e.container.querySelector(".theme-code-block"),portalStyle:e.portalStyle},e.children)}function C(e){const[t,n]=a.useState(0),[o,l]=a.useState(null);let i;e.setup.stages&&(i=e.setup.stages[t]);const r=i?.highlights??[],s=i?.arrows??[],u=[],c=[];if(e.container&&r.length>0){const t=e.container.querySelector("pre>code");t&&(function(e,t,n){for(const a of t){const t=(0,p.MU)(a),o=(0,p.Je)(e,t);n.push(o)}}(t,r,u),function(e,t,n,a){for(const o of n){const n=(0,p.CE)(e,o.line,t);a.push({arrow:o,bounds:n})}}(t,e.container,s,c))}const d=null!==o,m=e.setup.stages.length,h=()=>{n((e=>(e+1)%m))},f=()=>{l(setInterval((()=>{h()}),e.setup.autoPlayInterval||1e3))},g=()=>{o&&(clearInterval(o),l(null))};return(0,a.useEffect)((()=>(e.setup.runOnStart&&f(),()=>{g()})),[]),a.createElement(a.Fragment,null,e.setup.showControlButtons&&a.createElement(b,{running:d,onResume:f,onPause:g,onStepForward:()=>{g(),h()},onStepBackward:()=>{g(),n((e=>(e-1+m)%m))},currentStep:t+1,totalSteps:m}),a.createElement(N,{container:e.container},u.map(((e,n)=>e&&a.createElement(w,{key:`hgh-${t}-${n}`,bounds:e,variant:(0,p.US)(r[n])})))),a.createElement(_,{container:e.container,portalStyle:{zIndex:1,position:"absolute"}},c.map(((e,n)=>a.createElement(v,{key:`arr-${t}-${n}`,arrow:e.arrow,lineBounds:e.bounds,variant:e.arrow.variant})))))}function E(e){const t=(0,a.useRef)(null),n=(0,a.useRef)(null),[l,i]=a.useState(!1),[r,s]=a.useState(null),[u,p]=a.useState(null);(0,a.useEffect)((()=>{s(t.current)}),[t]),(0,a.useEffect)((()=>{p(n.current)}),[n]);const d="number"==typeof e.maxLines,m={};if(d){const t=1.43*Math.max(5,e.maxLines);m.height=`${t}em`}(0,a.useEffect)((()=>{const e=l?n.current:t.current;if(!e)return;const a=e.querySelector(".prism-code");a&&(a.style.overflowY="auto",a.style.overflowX="auto");const o=e.querySelector(".prism-code")?.parentNode;o&&(o.style.display="flex",o.style.height=`${m.height}`,o.style.overflow="hidden",o.style.resize="vertical",o.style.minHeight="40px",o.style.maxHeight="90vh",o.style.flexDirection="column")}),[l,t,n]);const h=()=>{const e=()=>i(!l),t=document;t.startViewTransition?t.startViewTransition(e):e()};return a.createElement(a.Fragment,null,e.inspectionSetup&&a.createElement(C,{container:r,setup:e.inspectionSetup}),a.createElement("div",{ref:t,style:{display:l?"none":"block"}},e.children),e.fullCode&&a.createElement(a.Fragment,null,a.createElement(c,{container:r,onShowFullCode:h}),a.createElement("div",{ref:n,style:{display:l?"block":"none"}},"string"==typeof e.fullCode?a.createElement(o.Z,{language:"cpp"},e.fullCode):e.fullCode),a.createElement(c,{container:u,onShowFullCode:h})))}E.isMDXComponent=!0},99801:(e,t,n)=>{n.d(t,{Z:()=>u});var a=n(67294),o=n(74866),l=n(85162),i=n(99372),r=n(72412);const s={};function u(e){const t=e.content||{};return a.createElement(o.Z,null,Object.entries(t).map(((e,t)=>{let[n,u]=e;return u.value||u.simplified||u.detailed?a.createElement(l.Z,{value:n,label:i.gJ.get(n),default:u.default||0==t},u.simplified?a.createElement(a.Fragment,null,a.createElement(o.Z,{groupId:"view_mode",className:s.smallTabs},a.createElement(l.Z,{value:"simplified",label:"Simplified",default:!0},(0,r.Z)(u.simplified)),a.createElement(l.Z,{value:"detailed",label:"Detailed"},(0,r.Z)(u.detailed)))):u.value):a.createElement(l.Z,{value:n,label:i.gJ.get(n),default:0==t},(0,r.Z)(u))})))}},55059:(e,t,n)=>{n.d(t,{mN:()=>c,ZP:()=>u});var a=n(67294),o=n(72412);const l={symbolTable:"symbolTable_yosy",symbolName:"symbolName__gUy",symbolDesc:"symbolDesc_wDaQ",symbolProp:"symbolProp_oAcv",accessPublic:"accessPublic_LfqG",accessProtected:"accessProtected_bDL6",accessPrivate:"accessPrivate_Ab5O",modStatic:"modStatic_ZSC5",modConstexpr:"modConstexpr_iypt",modConst:"modConst_osuL",modVolatile:"modVolatile_ePYM",modVirtual:"modVirtual_jNz7"};var i=n(98839);const r={None:{Order:0,ShortName:"",FullName:"",Style:l.accessPublic},Public:{Order:1,ShortName:"pub",FullName:"public",Style:l.accessPublic},Protected:{Order:2,ShortName:"prot",FullName:"protected",Style:l.accessProtected},Private:{Order:3,ShortName:"priv",FullName:"private",Style:l.accessPrivate}},s=e=>e.none?r.None:e.pub||e.public?r.Public:e.prot||e.protected?r.Protected:e.priv||e.private?r.Private:r.Public;function u(e){return(t=>{if(0===t.length)return null;const n=t.sort(((e,t)=>s(e).Order<s(t).Order));return a.createElement("table",{"data-no-traits":`${e.noTraits||"false"}`,className:l.symbolTable},a.createElement("tbody",null,n))})(a.Children.toArray(e.children))}function c(e){a.useContext(i.z);let t=(0,o.Z)(e.name),n=null;e.desc?n=e.desc:e.children&&(n=e.children);const r=e.linkName||e.autoLink;!e.noLink&&r&&(t=a.createElement("a",{href:e.link||`${e.linkName||e.name}`},t));const u=(e,t,n)=>!0===e?a.createElement("span",{className:l[t]},n):null;return a.createElement("tr",null,!e.none&&a.createElement("td",{className:l.symbolProp},(e=>{const t=s(e);return a.createElement("span",{className:t.Style},t.ShortName)})(e),u(e.static,"modStatic","static"),u(e.constexpr,"modConstexpr","constexpr"),u(e.const,"modConst","const"),u(e.volatile,"modVolatile","volatile"),u(e.virtual,"modVirtual","virtual")),a.createElement("td",{className:l.symbolName},t),a.createElement("td",{className:l.symbolDesc},(0,o.Z)(n)))}c.isMDXComponent=!0,u.isMDXComponent=!0,u.Symbol=c},99372:(e,t,n)=>{n.d(t,{gJ:()=>c,eH:()=>h,U6:()=>d,OS:()=>m});var a=n(67294),o=n(95999);const l="markedText_c6kK",i="since_c1Q3",r="until_jXK6",s="removed_A_Kf",u="versionNumber_BiUX",c=new Map;function p(e){let{children:t,className:n}=e;return a.createElement("span",{className:l+(n?" "+n:"")},t)}function d(e){let{children:t,v:n}=e;return a.createElement(p,{className:i},t,"\xa0",a.createElement("span",{className:u},a.createElement("small",null,"(",c.get(`since-${n}`),")")))}function m(e){let{children:t,v:n}=e;return a.createElement(p,{className:r},t,"\xa0",a.createElement("span",{className:u},a.createElement("small",null,"(",c.get(`until-${n}`),")")))}function h(e){let{children:t,v:n}=e;return a.createElement(p,{className:s},t,"\xa0",a.createElement("span",{className:u},a.createElement("small",null,"(",c.get(`removed-${n}`),")")))}c.set("cpp98","C++98"),c.set("cpp03","C++03"),c.set("cpp11","C++11"),c.set("cpp14","C++14"),c.set("cpp17","C++17"),c.set("cpp20","C++20"),c.set("cpp23","C++23"),c.set("deprecated-",a.createElement(o.Z,null,"deprecated")),c.set("deprecated-cpp98",a.createElement(o.Z,null,"deprecated in C++98")),c.set("deprecated-cpp03",a.createElement(o.Z,null,"deprecated in C++03")),c.set("deprecated-cpp11",a.createElement(o.Z,null,"deprecated in C++11")),c.set("deprecated-cpp14",a.createElement(o.Z,null,"deprecated in C++14")),c.set("deprecated-cpp17",a.createElement(o.Z,null,"deprecated in C++17")),c.set("deprecated-cpp20",a.createElement(o.Z,null,"deprecated in C++20")),c.set("deprecated-cpp23",a.createElement(o.Z,null,"deprecated in C++23")),c.set("until-cpp98",a.createElement(o.Z,null,"until C++98")),c.set("until-cpp03",a.createElement(o.Z,null,"until C++03")),c.set("until-cpp11",a.createElement(o.Z,null,"until C++11")),c.set("until-cpp14",a.createElement(o.Z,null,"until C++14")),c.set("until-cpp17",a.createElement(o.Z,null,"until C++17")),c.set("until-cpp20",a.createElement(o.Z,null,"until C++20")),c.set("until-cpp23",a.createElement(o.Z,null,"until C++23")),c.set("since-cpp98",a.createElement(o.Z,null,"since C++98")),c.set("since-cpp03",a.createElement(o.Z,null,"since C++03")),c.set("since-cpp11",a.createElement(o.Z,null,"since C++11")),c.set("since-cpp14",a.createElement(o.Z,null,"since C++14")),c.set("since-cpp17",a.createElement(o.Z,null,"since C++17")),c.set("since-cpp20",a.createElement(o.Z,null,"since C++20")),c.set("since-cpp23",a.createElement(o.Z,null,"since C++23")),c.set("removed-",a.createElement(o.Z,null,"deleted")),c.set("removed-cpp98",a.createElement(o.Z,null,"removed in C++98")),c.set("removed-cpp03",a.createElement(o.Z,null,"removed in C++03")),c.set("removed-cpp11",a.createElement(o.Z,null,"removed in C++11")),c.set("removed-cpp14",a.createElement(o.Z,null,"removed in C++14")),c.set("removed-cpp17",a.createElement(o.Z,null,"removed in C++17")),c.set("removed-cpp20",a.createElement(o.Z,null,"removed in C++20")),c.set("removed-cpp23",a.createElement(o.Z,null,"removed in C++23"))},72412:(e,t,n)=>{function a(e){return"object"!=typeof e||Array.isArray(e)||void 0!==e.type?e:e.props.children}n.d(t,{Z:()=>a})},60177:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>u});var a=n(87462),o=(n(67294),n(3905));const l={},i=void 0,r={unversionedId:"std/algo/_codes/niebloids/adl",id:"std/algo/_codes/niebloids/adl",title:"adl",description:"",source:"@site/content/docs/std/algo/_codes/niebloids/adl.mdx",sourceDirName:"std/algo/_codes/niebloids",slug:"/std/algo/_codes/niebloids/adl",permalink:"/CppLangNet/docs/std/algo/_codes/niebloids/adl",draft:!1,editUrl:"https://github.com/Cpp4You/CppLangNet/edit/main/content/docs/std/algo/_codes/niebloids/adl.mdx",tags:[],version:"current",frontMatter:{}},s={},u=[],c={toc:u};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <cstdio>\n#include <print>\n\nnamespace my_ns\n{\n  enum class MyEnum\n  {\n    One = 1,\n    Two = 2\n  };\n\n  auto print_me(MyEnum my_enum) -> void\n  {\n    switch(my_enum) {\n      case MyEnum::One: std::print("One :D\\n"); break;\n      case MyEnum::Two: std::print("One :D\\n"); break;\n      default: std::print("Boooo D:\\n");\n    }\n  }\n}\n\nauto main() -> int\n{\n    print_me(my_ns::MyEnum::One);\n}\n')))}p.isMDXComponent=!0},92328:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>u});var a=n(87462),o=(n(67294),n(3905));const l={},i=void 0,r={unversionedId:"std/algo/_codes/niebloids/qualified-unqualified-lookup",id:"std/algo/_codes/niebloids/qualified-unqualified-lookup",title:"qualified-unqualified-lookup",description:"",source:"@site/content/docs/std/algo/_codes/niebloids/qualified-unqualified-lookup.mdx",sourceDirName:"std/algo/_codes/niebloids",slug:"/std/algo/_codes/niebloids/qualified-unqualified-lookup",permalink:"/CppLangNet/docs/std/algo/_codes/niebloids/qualified-unqualified-lookup",draft:!1,editUrl:"https://github.com/Cpp4You/CppLangNet/edit/main/content/docs/std/algo/_codes/niebloids/qualified-unqualified-lookup.mdx",tags:[],version:"current",frontMatter:{}},s={},u=[],c={toc:u};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <cstdio>\n#include <print>\n\nnamespace my_ns\n{\n  enum class MyEnum\n  {\n    One = 1,\n    Two = 2\n  };\n\n  auto print_me(MyEnum my_enum) -> void\n  {\n    switch(my_enum) {\n      case MyEnum::One: std::print("One :D\\n"); break;\n      case MyEnum::Two: std::print("One :D\\n"); break;\n      default: std::print("Boooo D:\\n");\n    }\n  }\n}\n\nstruct Hello\n{\n  auto world() const -> std::string\n  {\n    return "Helo, world!";\n  }\n};\n\nauto main() -> int\n{\n  {\n    // auto value = my_ns::x; // Qualified lookup\n    // The above fails, because `x` is not present in my_ns namespace\n\n    // krabby_patty::patty_krabby(mr_krabs::secret_recipe); // Qualified lookup\n    // The above fails, because namespaces `krabby_patty` and `mr_krabs` are not present\n\n    std::print("Hello {}!", "World"); // Qualified lookup\n\n    auto value = my_ns::MyEnum::One; // Qualified lookup\n\n    ::printf("Hello %s!", "World"); // Qualified lookup\n    // If there\'s nothing to the left of the scope resolution operator, it\'s refering to the global namespace\n  }\n\n  Hello hello; // Unqualified lookup to Hello, which is found in global scope\n\n  {\n    // auto value = x; // Unqualified lookup, no scope resolution operator\n    // The above fails, because `x` is nowhere to be found\n\n    // foo(1, 2, 3); // Unqualified lookup, no scope resolution operator\n    // The above fails, because `foo` is nowhere to be found\n\n    std::print("{}", hello.world()); // Qualified lookup to `std::print`, unqualified lookup to `hello`, which is found in upper scope\n    // Unqualified searches starting from the current scope up\n\n    print_me(my_ns::MyEnum::One);\n    // Unqualified lookup to `print_me`, qualified lookup to my_ns::MyEnum::One\n    // But wait... print_me is not present in this scope, upper scope, nor global scope, how does that work??\n    // Is it a bug, magic, or maybe... ADL? :P\n  }\n}\n')))}p.isMDXComponent=!0},63219:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>u,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var a=n(87462),o=(n(67294),n(3905)),l=(n(99801),n(55059),n(99372),n(66830)),i=n(92328),r=n(60177);const s={title:"What are niebloids?",description:"Explanation of niebloids.",hide_title:!0,tags:["niebloid","adl","unqualified","qualified","lookup","cpo"]},u=void 0,c={unversionedId:"std/algo/niebloids",id:"std/algo/niebloids",title:"What are niebloids?",description:"Explanation of niebloids.",source:"@site/content/docs/std/algo/niebloids.mdx",sourceDirName:"std/algo",slug:"/std/algo/niebloids",permalink:"/CppLangNet/docs/std/algo/niebloids",draft:!1,editUrl:"https://github.com/Cpp4You/CppLangNet/edit/main/content/docs/std/algo/niebloids.mdx",tags:[{label:"niebloid",permalink:"/CppLangNet/docs/tags/niebloid"},{label:"adl",permalink:"/CppLangNet/docs/tags/adl"},{label:"unqualified",permalink:"/CppLangNet/docs/tags/unqualified"},{label:"qualified",permalink:"/CppLangNet/docs/tags/qualified"},{label:"lookup",permalink:"/CppLangNet/docs/tags/lookup"},{label:"cpo",permalink:"/CppLangNet/docs/tags/cpo"}],version:"current",frontMatter:{title:"What are niebloids?",description:"Explanation of niebloids.",hide_title:!0,tags:["niebloid","adl","unqualified","qualified","lookup","cpo"]}},p={},d=[{value:"Qualified vs Unqualified Lookup",id:"qualified-vs-unqualified-lookup",level:2},{value:"Argument Dependent Lookup",id:"argument-dependent-lookup",level:2},{value:"Unqualified lookup and ADL together",id:"unqualified-lookup-and-adl-together",level:2},{value:"Customization Points",id:"customization-points",level:2},{value:"Customization Points are flawed, Customization Point Objects to the rescue",id:"customization-points-are-flawed-customization-point-objects-to-the-rescue",level:2},{value:"Niebloids",id:"niebloids-1",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Reasoning",id:"reasoning",level:3}],m={toc:d};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"niebloids"},"Niebloids"),(0,o.kt)("p",null,"Niebloids as a concept and pattern existed for a long time, they were first introduced by ",(0,o.kt)("a",{parentName:"p",href:"https://ericniebler.com/about/"},(0,o.kt)("strong",{parentName:"a"},"Eric Niebler")),"\nin his C++14 ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ericniebler/range-v3/"},(0,o.kt)("strong",{parentName:"a"},"range-v3"))," library."),(0,o.kt)("p",null,"The name was suggested by the author himself in a ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/tcanens/status/1063723279414890496"},"poll on twitter in 2018"),"."),(0,o.kt)("p",null,"Before getting to niebloids and understanding fully what these give us, we first have to have some understanding in the following topics:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Unqualified lookup / Qualified lookup"),(0,o.kt)("li",{parentName:"ul"},"ADL (Argument Dependent Lookup)"),(0,o.kt)("li",{parentName:"ul"},"Customization Points"),(0,o.kt)("li",{parentName:"ul"},"Customization Point Objects")),(0,o.kt)("p",null,"We will briefly go over them. You can skip to the last section if you are already familiar with them."),(0,o.kt)("h2",{id:"qualified-vs-unqualified-lookup"},"Qualified vs Unqualified Lookup"),(0,o.kt)("p",null,"When we use any kind of an identifier in our code, lookup happens - the compiler tries to determine where the identifier\nis from and what it means in our code - is it a class/an object/a function? What type does it have? What namespace is it in? Etc."),(0,o.kt)("p",null,"We won't delve deeply into the details, because both are pretty complicated, but all we want to know is that\nthe latter - unqualified lookup - is what we want."),(0,o.kt)("p",null,"Syntatically, qualified lookup implies the use of ",(0,o.kt)("a",{parentName:"p",href:"#"},(0,o.kt)("strong",{parentName:"a"},"scope resolution operator"))," - ",(0,o.kt)("inlineCode",{parentName:"p"},"::"),", that is:"),(0,o.kt)(l.Z,{fullCode:(0,o.kt)(i.default,{mdxType:"FullCode_Qualified_Unqualified_Lookup"}),mdxType:"CustomCodeBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'{\n  // auto value = my_ns::x; // Qualified lookup\n  // The above fails, because `x` is not present in my_ns namespace\n\n  // krabby_patty::patty_krabby(mr_krabs::secret_recipe); // Qualified lookup\n  // The above fails, because namespaces `krabby_patty` and `mr_krabs` are not present\n\n  std::print("Hello {}!", "World"); // Qualified lookup\n\n  auto value = my_ns::MyEnum::One; // Qualified lookup\n\n  ::printf("Hello %s!", "World"); // Qualified lookup\n  // If there\'s nothing to the left of the scope resolution operator, it\'s refering to the global namespace\n}\n\nHello hello; // Unqualified lookup to Hello, which is found in global scope\n\n{\n  // auto value = x; // Unqualified lookup, no scope resolution operator\n  // The above fails, because `x` is nowhere to be found\n\n  // foo(1, 2, 3); // Unqualified lookup, no scope resolution operator\n  // The above fails, because `foo` is nowhere to be found\n\n  std::print("{}", hello.world()); // Qualified lookup to `std::print`, unqualified lookup to `hello`, which is found in upper scope\n  // Unqualified searches starting from the current scope up\n\n  print_me(my_ns::MyEnum::One);\n  // Unqualified lookup to `print_me`, qualified lookup to my_ns::MyEnum::One\n  // This works.\n  // But wait... print_me is not present in this scope, upper scope, nor global scope,\n  // unqualified lookup didn\'t pick it up, so how does that work??\n  // Is it a bug, magic, or maybe... ADL? :P\n}\n'))),(0,o.kt)("p",null,"Both of these do a little bit different things, but unqualified lookup has one special property, ",(0,o.kt)("strong",{parentName:"p"},"A"),"rgument ",(0,o.kt)("strong",{parentName:"p"},"D"),"ependent ",(0,o.kt)("strong",{parentName:"p"},"L"),"ookup\nfollows after it."),(0,o.kt)("h2",{id:"argument-dependent-lookup"},"Argument Dependent Lookup"),(0,o.kt)("p",null,"Argument Dependent Lookup (also sometimes reffered to as ",(0,o.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20180317070215/http://www.drdobbs.com/cpp/a-personal-note-about-argument-dependent/232901443"},(0,o.kt)("strong",{parentName:"a"},"Koenig lookup")),")\nor ADL for short is a very advanced topic in itself, but in short, what it allows is\ncalling functions from the argument's respective namespaces without qualifying them explicitly."),(0,o.kt)("p",null,"That sounds pretty complicated, but here's a simple example you've already seen and written a thousand times probably:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'std::cout << "Hello, world!";\n')),(0,o.kt)("p",null,"Yep. What we see above would not work if it wasn't for ADL. Here's how the code above looks to the compiler:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'operator<<(std::cout, "Hello, world!");\n')),(0,o.kt)("p",null,"You could even write this code yourself and see that it would compile\n(though, of course, no one would write code like this for real, it's not very practical and eliminates the convenience of overloading operators)."),(0,o.kt)("p",null,"Here's the example from the previous section about lookup:"),(0,o.kt)(l.Z,{fullCode:(0,o.kt)(r.default,{mdxType:"FullCode_Adl"}),mdxType:"CustomCodeBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"print_me(my_ns::MyEnum::One);\n"))),(0,o.kt)("p",null,"You may be surprised it works - intuiton tells us that it shouldn't, because even though we have a fully qualified ",(0,o.kt)("inlineCode",{parentName:"p"},"my_ns::MyEnum::One")," which\nis resolved via qualified lookup correctly, ",(0,o.kt)("inlineCode",{parentName:"p"},"print_me")," is not qualified and not be present in this scope, unqualified lookup shouldn't find it and this code should not compile."),(0,o.kt)("p",null,"And your intuition would be right.. At least if it wasn't for ADL."),(0,o.kt)("p",null,"What ADL does is actually very simple","*"," - when you perform an unqualified call to a function, ADL follows and looks at the types of\nthe arguments of the functions and adds all the functions from each namespace the types of the arguments participate in to the resolution set."),(0,o.kt)("p",null,"That is, when performing Argument Dependent Lookup on this function call:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"print_me(my_ns::MyEnum::One);\n")),(0,o.kt)("p",null,"We look at the type of the arguments, in this case ",(0,o.kt)("inlineCode",{parentName:"p"},"my_ns::MyEnum"),", and add it's namespace (",(0,o.kt)("inlineCode",{parentName:"p"},"my_ns"),") to the resolution set."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"my_ns")," does indeed contain ",(0,o.kt)("inlineCode",{parentName:"p"},"print_me")," which accepts ",(0,o.kt)("inlineCode",{parentName:"p"},"MyEnum::One")," as an argument, so it's found and later called."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"*"," - well, it's actually a more complicated than that and it does a little bit more things, but that's the gist and\nthat's what's actually important here")),(0,o.kt)("h2",{id:"unqualified-lookup-and-adl-together"},"Unqualified lookup and ADL together"),(0,o.kt)("p",null,"Unqualified Lookup and Argument Dependent Lookup work together, one after another.\nThe important rule to keep in mind about ADL - it is ",(0,o.kt)("strong",{parentName:"p"},"not performed")," after unqualified lookup in several different cases."),(0,o.kt)("p",null,"One of these cases that is of interest to us is when unqualified lookup finds a declaration that is"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"neither a ",(0,o.kt)("strong",{parentName:"li"},"function")),(0,o.kt)("li",{parentName:"ul"},"nor a ",(0,o.kt)("strong",{parentName:"li"},"function template"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"auto x = 2137;\nauto y = x + 1; // unqualified lookup for x, no ADL because x is an object\n")),(0,o.kt)("p",null,"And if you think about it - it makes sense, ADL should only apply to function calls, it doesn't make sense to apply\nADL to an object that was being looked up. An object doesn't accept any parameters that we can examine."),(0,o.kt)("p",null,"Why am I talking about it? Because it's crucial for understanding Niebloids."),(0,o.kt)("p",null,"So once again, keep in mind - ",(0,o.kt)("span",{class:"inline-important"},"ADL doesn't happen if unqualified lookup found something that is neither a function nor a function template")),(0,o.kt)("h2",{id:"customization-points"},"Customization Points"),(0,o.kt)("p",null,"One of the ways we can utilize ADL in is making so called Customization Points."),(0,o.kt)("p",null,"You may not know about it, but you've probably used them yourself several times."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"std::swap"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"std::data"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"std::begin"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"std::end")," - these are all customization points."),(0,o.kt)("p",null,'If you have a custom type which has a special, more performant or otherwise better implementation of any of these\nfunctions above, you can "hook" your own implementations by creating a free function with a similar interface in your type\'s namespace.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"namespace my_ns {\n\nstruct MyAwesomeType { };\n\nauto swap(MyAwesomeType& first, MyAwesomeType& second) -> void {\n  // awesome implementation\n}\n\n}\n")),(0,o.kt)("p",null,"The consequence of having such a design is that now the programmer has to remember about these Customization Points\nand handle them properly. What it means, is that everytime you write generic code, you have to remember to bring\nthe default implementation to the current scope and call it unqualified, e.g.:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename T, typename U>\nauto awesome_function(T t, U u)\n{\n  using std::swap;\n  swap(t, u);\n}\n")),(0,o.kt)("p",null,'This ensures that if the type has "hooked" into the customization point, it will be called, but if not, the default\nimplementation will be chosen.'),(0,o.kt)("p",null,"So, remember, everytime you see code like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::swap(a, b);\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"b")," are some generic parameters - it's probably a bug."),(0,o.kt)("h2",{id:"customization-points-are-flawed-customization-point-objects-to-the-rescue"},"Customization Points are flawed, Customization Point Objects to the rescue"),(0,o.kt)("p",null,"The two problems with Customization Points are that, first of all, the programmer has to remember\nto correctly use them in generic code (doing more to achieve the correct thing) and, second of all,\nif the standard decides to add some requirements to the types of these customization points\n(for example, ",(0,o.kt)("inlineCode",{parentName:"p"},"Range"),", for ",(0,o.kt)("inlineCode",{parentName:"p"},"begin"),', which is pretty sensible), it would not be possible to apply them to the "hooked", custom\nimplementations.'),(0,o.kt)("p",null,"These problems are solved by ",(0,o.kt)("strong",{parentName:"p"},"C"),"ustomization ",(0,o.kt)("strong",{parentName:"p"},"P"),"oint ",(0,o.kt)("strong",{parentName:"p"},"O"),"objects, or CPOs in short."),(0,o.kt)("p",null,"They came to C++ together with the C++20 standard (",(0,o.kt)("a",{parentName:"p",href:"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html"},"paper which introduced them"),")."),(0,o.kt)("p",null,"CPOs have two main goals:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"define a central point to apply requirements to"),(0,o.kt)("li",{parentName:"ul"},'define a central point to call, which will dispatch to either the "hooked" implementation or the default standard implementation')),(0,o.kt)("p",null,"The second goal is done by inhibiting (disallowing) ADL."),(0,o.kt)("p",null,"The are currently only two ways to achieve that."),(0,o.kt)("p",null,"One of them is to to make them function objects, as specified in the ",(0,o.kt)("a",{parentName:"p",href:"#unqualified-lookup-and-adl-together"},"Unqualified lookup and ADL together")," section,\nADL doesn't happen if unqualified lookup happens to find something that is neither a ",(0,o.kt)("strong",{parentName:"p"},"function"),", nor a ",(0,o.kt)("strong",{parentName:"p"},"function template")," - a function object\nis none of those, so ADL is disabled."),(0,o.kt)("p",null,"The other way to implement such behaviour is to use internal compiler extensions, but no known implementation does that currently."),(0,o.kt)("h2",{id:"niebloids-1"},"Niebloids"),(0,o.kt)("p",null,"Finally, we come to the pinnacle of this article - niebloids."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/algorithm/ranges/all_any_none_of"},"Cppreference*")," tells us that the key characteristics of a niebloid are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Niebloids inhibit ADL"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("span",{class:"inline-caution"},"Explicit template arguments cannot be specified"),"**")),(0,o.kt)("p",null,"You may also stumble upon people mentioning, that ",(0,o.kt)("span",{class:"inline-danger"},"even though they are templated, they can be passed to higher order functions without any problem."),"*","*","*"),(0,o.kt)("span",null,"*")," Look at the end of the description of the algorithm, each and every rangified algorithm contains the same definition.",(0,o.kt)("h3",{id:"implementation"},"Implementation"),(0,o.kt)("p",null,"You may notice, that niebloids have similar goals to CPOs. And, yeah, they are pretty much the same, except that niebloids\ndon't allow for any customization points. Similarily to CPOs, they are also typically implemented using function objects,\nalthough that's not required."),(0,o.kt)("span",null,"**")," One of the characteristics specified is not being able to specify explicit template arguments, it is true with how niebloids are currently implemented by all the major vendors, but keep in mind that it's not a planned feature of niebloids and just a side effect of niebloids being implemented as function objects. This behaviour may change in the future, if vendors decide to conjure a special extension for ease of implementation/maintainability.",(0,o.kt)("br",null)," ",(0,o.kt)("br",null),(0,o.kt)("span",null,"***")," People also sometimes mention, that one of the advantages of niebloids over ordinary functions is that you can pass them to higher order functions (functions taking other functions as arguments, in this context) with no problem.",(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <algorithm>\n#include <vector>\n\ntemplate <typename Fun>\nauto do_thing(std::vector<int>& ints1, std::vector<int>& ints2, Fun fun)\n{\n  fun(ints1, ints2);\n}\n\nauto main() -> int\n{\n  auto ints1 = std::vector { 5, 4, 3, 2, 1 };\n  auto ints2 = std::vector { 1, 2, 3, 4, 5 };\n  do_thing(ints1, ints2, std::ranges::swap); // Would not compile with std::swap\n}\n")),(0,o.kt)("p",null,"And while it is true for range-v3, because the key design is to use function objects and have these advantages,\nit's not true for ",(0,o.kt)("inlineCode",{parentName:"p"},"std::")," niebloids, the standard doesn't specify they have to be implemented to allow such behaviour."),(0,o.kt)("p",null,"This means you ",(0,o.kt)("strong",{parentName:"p"},"should not")," rely on this behaviour, because your code may break in the future."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Ways to pass such a function to HOF"),(0,o.kt)("p",null,"If you have a need to pass such a function to some HOF, you can use a lambda that mimics the intended interface:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <algorithm>\n#include <vector>\n\ntemplate <typename Fun>\nauto do_thing(std::vector<int>& ints1, std::vector<int>& ints2, Fun fun)\n{\n  fun(ints1, ints2);\n}\n\nauto main() -> int\n{\n  auto ints1 = std::vector { 5, 4, 3, 2, 1 };\n  auto ints2 = std::vector { 1, 2, 3, 4, 5 };\n  do_thing(ints1, ints2, [](auto& a, auto &b) { std::swap(a, b); }); // Compiles, tho requires thinking and typing\n\n  std::cout << ints1[0] << ' ' << ints2[0];\n}\n")),(0,o.kt)("p",null,"Or write a very scary looking generic macro which abstracts that away:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <algorithm>\n#include <vector>\n\n#include <algorithm>\n#include <vector>\n\n#define LIFT_FWD_(...) (static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__))\n#define LIFT(...) \\\n  [](auto&&... args) \\\n    noexcept(noexcept(__VA_ARGS__(LIFT_FWD_(args)...))) \\\n    -> decltype(__VA_ARGS__(LIFT_FWD_(args)...)) \\\n    { return __VA_ARGS__(LIFT_FWD_(args)...); }\n\ntemplate <typename Fun>\nauto do_thing(std::vector<int>& ints1, std::vector<int>& ints2, Fun fun)\n{\n  fun(ints1, ints2);\n}\n\nauto main() -> int\n{\n  auto ints1 = std::vector { 5, 4, 3, 2, 1 };\n  auto ints2 = std::vector { 1, 2, 3, 4, 5 };\n  do_thing(ints1, ints2, LIFT(std::swap)); // Compiles, black boxed magic that just works^tm\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Explanation of the above macro"),(0,o.kt)("p",null,"The above macro is a lot of magic, yes, but it basically handles everything properly and correctly for us."),(0,o.kt)("p",null,"First we define ",(0,o.kt)("inlineCode",{parentName:"p"},"LIFT_FWD_")," which basically does what ",(0,o.kt)("a",{parentName:"p",href:"/docs/std/utility/forward/"},(0,o.kt)("inlineCode",{parentName:"a"},"std::forward"))," does. If you don't know how\nit works, follow the above link and read the explanation there."),(0,o.kt)("p",null,"We define it as a macro, instead of using the function from stdlib directly, because it makes no sense to include the ",(0,o.kt)("inlineCode",{parentName:"p"},"<utility>")," header for our macro."),(0,o.kt)("p",null,"The lift macro itself can be broken into four parts:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"[](auto&&... args) // just the starting declaration of a lambda, nothing fancy, we are talking a parameter pack of whatever arguments\nnoexcept(noexcept(__VA_ARGS__(LIFT_FWD_(args)...))) // we are correctly handling the noexcept case - if our function call is noexcept, our lambda is noexcept as well\n-> decltype(__VA_ARGS__(LIFT_FWD_(args)...)) // we are taking the return type of our function call and setting it as our lambda return type\n{ return __VA_ARGS__(LIFT_FWD_(args)...); } // the body, actual function call\n")),(0,o.kt)("p",null,"The only confusing part may be ",(0,o.kt)("inlineCode",{parentName:"p"},"__VA_ARGS__"),", why not just ",(0,o.kt)("inlineCode",{parentName:"p"},"#define LIFT(X) [...] X(LIFT_FWD_(args)...)"),"?"),(0,o.kt)("p",null,"The answer is - this would work, probably even 99% of the cases, but woud disallow passing in a type with explicit template parameters and a space in it, consider:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"LIFT(something<int, std::string>)\n")),(0,o.kt)("p",null,"The space in there would make ",(0,o.kt)("inlineCode",{parentName:"p"},"X")," only be ",(0,o.kt)("inlineCode",{parentName:"p"},"something<int"),", so that's just a way to protect against that."))),(0,o.kt)("h3",{id:"reasoning"},"Reasoning"),(0,o.kt)("p",null,"The whole point of niebloids is to make doing the correct thing easy and convenient, without the programmer having to care\nor remember any rules."),(0,o.kt)("p",null,"By inhibiting (disallowing) ADL, the behaviour of calling an algorithm is consistent with both qualified and unqualified lookup:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"auto const numbers = std::vector{ 1 ,2, 3, 4, 5 };\n{\n  auto const min = std::ranges::min(numbers); // Calls std::ranges::min\n}\n\n{\n  using namespace std::ranges;\n  auto const min = min(numbers); // Calls std::ranges::min\n}\n")),(0,o.kt)("p",null,"Then, niebloids correctly take care of everything inside. They call Customization Point Objects if neccessary, which\ntake care of correct handling of customization points and all type requirements are correctly applied."))}h.isMDXComponent=!0}}]);