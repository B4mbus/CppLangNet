"use strict";(self.webpackChunkcpp_lang_net=self.webpackChunkcpp_lang_net||[]).push([[32102],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),m=o,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||r;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},50637:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>p,toc:()=>u});var a=n(87462),o=(n(67294),n(3905)),r=n(74866),i=n(85162);n(56693);const l={title:"Introduction to Conditions",description:"Lesson: condition basics in C++",tags:["condition","if","else","else-if","compound","boolean","bool"],hide_title:!0},s=void 0,p={unversionedId:"course/basics/conditions/intro",id:"course/basics/conditions/intro",title:"Introduction to Conditions",description:"Lesson: condition basics in C++",source:"@site/content/learn/course/basics/conditions/intro.mdx",sourceDirName:"course/basics/conditions",slug:"/course/basics/conditions/intro",permalink:"/CppLangNet/learn/course/basics/conditions/intro",draft:!1,editUrl:"https://github.com/Cpp4You/CppLangNet/edit/main/content/learn/course/basics/conditions/intro.mdx",tags:[{label:"condition",permalink:"/CppLangNet/learn/tags/condition"},{label:"if",permalink:"/CppLangNet/learn/tags/if"},{label:"else",permalink:"/CppLangNet/learn/tags/else"},{label:"else-if",permalink:"/CppLangNet/learn/tags/else-if"},{label:"compound",permalink:"/CppLangNet/learn/tags/compound"},{label:"boolean",permalink:"/CppLangNet/learn/tags/boolean"},{label:"bool",permalink:"/CppLangNet/learn/tags/bool"}],version:"current",frontMatter:{title:"Introduction to Conditions",description:"Lesson: condition basics in C++",tags:["condition","if","else","else-if","compound","boolean","bool"],hide_title:!0},sidebar:"defaultSidebar",previous:{title:"Variables \xbb Exercises",permalink:"/CppLangNet/learn/course/basics/variables/exercises"},next:{title:"Introduction to Conditions",permalink:"/CppLangNet/learn/course/basics/conditions/intro"}},d={},u=[{value:"Code preparation",id:"code-preparation",level:2},{value:"Conditional statements",id:"conditional-statements",level:2},{value:"Boolean expressions",id:"boolean-expressions",level:2},{value:"Boolean operators",id:"boolean-operators",level:3},{value:"Equality operators",id:"equality-operators",level:4},{value:"Relational operators",id:"relational-operators",level:4},{value:"Compound boolean expressions",id:"compound-boolean-expressions",level:3},{value:"Logical AND operator",id:"logical-and-operator",level:4},{value:"Logical OR operator",id:"logical-or-operator",level:4},{value:"Logical NOT operator",id:"logical-not-operator",level:4},{value:"Upgrading the Oracle",id:"upgrading-the-oracle",level:4},{value:"Order of Operations",id:"order-of-operations",level:3}],c={toc:u};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introduction-to-conditions"},"Introduction to Conditions"),(0,o.kt)("p",null,"So far, we've been creating programs that worked the same way every time.\nOur creations could not make decisions. Now is the time to change that.\nIn this lesson we will provide branching paths for our programs to execute\nbased on what the user types in. This will be a guided lesson in which we\nwill make an application that checks if the user can legally get a Driver's License. \ud83d\ude0e"),(0,o.kt)("h2",{id:"code-preparation"},"Code preparation"),(0,o.kt)("p",null,"Let's first ask the user for their year of birth."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nint main()\n{\n    std::cout << "Welcome to the Driver\'s License Oracle 2000\\n";\n    std::cout << "Please enter your year of birth: ";\n\n    int yearOfBirth;\n    std::cin >> yearOfBirth;\n\n    // Year 2022 at the moment of writing this lesson\n    int age = 2022 - yearOfBirth;\n\n    // highlight-start\n    // Case A:\n    std::cout << "You can legally get a driver\'s license\\n";\n    // highlight-end\n\n    // highlight-start\n    // Case B:\n    std::cout << "You cannot legally get a driver\'s license\\n";\n    // highlight-end\n}\n')),(0,o.kt)("p",null,"Here, I've highlighted two pieces of code \u2014 one where the user can legally get a driver's license,\nand another where they cannot. We only want one of these segments to execute, not both. How can we do that?\nFirst, we should specify what the \"cases\" are, and under what conditions they should execute."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Case A \u2014 Legal \u2014 This should be executed only when ",(0,o.kt)("inlineCode",{parentName:"li"},"age")," is greater than or equal to ",(0,o.kt)("inlineCode",{parentName:"li"},"18")),(0,o.kt)("li",{parentName:"ul"},"Case B \u2014 Illegal \u2014 This should be executed only when ",(0,o.kt)("inlineCode",{parentName:"li"},"age")," is less than ",(0,o.kt)("inlineCode",{parentName:"li"},"18"))),(0,o.kt)("p",null,"Continue on and you'll see how we can translate these cases into code."),(0,o.kt)("h2",{id:"conditional-statements"},"Conditional statements"),(0,o.kt)("p",null,"The simplest form of a condition in C++ is the ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," statement, the basic form of which is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83d\udd39 Anatomy of an if statement"',title:'"\ud83d\udd39',Anatomy:!0,of:!0,an:!0,if:!0,'statement"':!0},"if (/* boolean condition */) \n{\n    // The code in here executes only if the condition evaluates to true\n}\n\n// The code out here executes regardless of whether the condition is true or false\n")),(0,o.kt)("p",null,"To use an ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," statement, we need two things:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"A condition that results in a boolean ",(0,o.kt)("inlineCode",{parentName:"li"},"true"),"/",(0,o.kt)("inlineCode",{parentName:"li"},"false")," value when evaluated"),(0,o.kt)("li",{parentName:"ol"},"Code to execute when the condition evaluates to ",(0,o.kt)("inlineCode",{parentName:"li"},"true"))),(0,o.kt)("p",null,"After an ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," keyword, we put a boolean condition inside of parentheses.\nThen, the braces that surround #2 create what's known as a ",(0,o.kt)("strong",{parentName:"p"},"block of code"),". ",(0,o.kt)("u",null,"Everything inside this code block will be\nexecuted if and only if the condition is true"),". Variables that are created in a code block live and die with that\ncode block \u2014 they are destroyed when the block ends (with the closing brace ",(0,o.kt)("inlineCode",{parentName:"p"},"}")," ) and are completely inaccessible\nfrom outside it."),(0,o.kt)("p",null,"Let's apply this to our Driver's License example by combining the if statement with the cases we previously determined:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83d\udd39 First attempt at using if statements"',title:'"\ud83d\udd39',First:!0,attempt:!0,at:!0,using:!0,if:!0,'statements"':!0},'#include <iostream>\n\nint main()\n{\n    std::cout << "Welcome to the Driver\'s License Oracle 2000\\n";\n    std::cout << "Please enter your year of birth: ";\n\n    int yearOfBirth;\n    std::cin >> yearOfBirth;\n\n    // Year 2022 at the moment of writing this lesson\n    int age = 2022 - yearOfBirth;\n\n    // highlight-start\n    // Case A:\n    if (/* age is greater than or equal to 18*/)\n    {\n        std::cout << "You can legally get a driver\'s license\\n";\n    }\n    // highlight-end\n\n    // highlight-start\n    // Case B:\n    if (/* age is less than 18 */)\n    {\n        std::cout << "You cannot legally get a driver\'s license\\n";\n    }\n    // highlight-end\n}\n')),(0,o.kt)("p",null,"Notice here how we have two ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," statements, one for each case.\nThe first one handles our Case A, where they can legally obtain a driver's license.\nThe second one handles our Case B, where they cannot legally obtain a driver's license."),(0,o.kt)("p",null,"Upon closer inspection, one fact should quickly become obvious \u2014 these cases are ",(0,o.kt)("strong",{parentName:"p"},"mutually exclusive"),".\nThis means that it is not possible for both cases to be true; only one or the other can execute.\nC++ provides the ",(0,o.kt)("inlineCode",{parentName:"p"},"else")," keyword to delineate mutually exclusive conditions. While the above code\nwill work as expected, we can improve it like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83d\udd39 Anatomy of an if-else statement"',title:'"\ud83d\udd39',Anatomy:!0,of:!0,an:!0,"if-else":!0,'statement"':!0},"if (/* boolean condition */)\n{\n    // The code in here executes only if the condition evalutes to true\n}\nelse\n{\n    // The code in here executes only if the condition evalutes to false\n}\n\n// The code out here executes regardless of whether the condition is true or false\n")),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"else")," block is optional, and you should only use it if you want mutual exclusion."),(0,o.kt)("p",null,"Now we can turn back to our example and see only one condition is necessary,\nas if one is true then the other must be false."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83d\udd39 First attempt at using an if-else statement"',title:'"\ud83d\udd39',First:!0,attempt:!0,at:!0,using:!0,an:!0,"if-else":!0,'statement"':!0},'#include <iostream>\n\nint main()\n{\n    std::cout << "Welcome to the Driver\'s License Oracle 2000\\n";\n    std::cout << "Please enter your year of birth: ";\n\n    int yearOfBirth;\n    std::cin >> yearOfBirth;\n\n    // Year 2022 at the moment of writing this lesson\n    int age = 2022 - yearOfBirth;\n\n    // highlight-start\n    if (/* age is greater than or equal to 18*/)\n    {\n        std::cout << "You can legally get a driver\'s license\\n";\n    }\n    else\n    {\n        std::cout << "You cannot legally get a driver\'s license\\n";\n    }\n    // highlight-end\n}\n')),(0,o.kt)("admonition",{type:"danger"},(0,o.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"No semicolon ",(0,o.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},";")),(0,o.kt)("p",{parentName:"admonition"},"Don't put semicolon (",(0,o.kt)("inlineCode",{parentName:"p"},";"),") after the parentheses of the ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," statement.\nThis won't cause a compiler error but it ",(0,o.kt)("strong",{parentName:"p"},"will")," cause your code to\nnot behave correctly. The conditional code block will always be executed."),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"right",label:"\u2714 Right",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"if (age >= 18) \n// ...\nelse\n// ...\n"))),(0,o.kt)(i.Z,{value:"wrong",label:"\u274c Wrong",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"if (age >= 18);\n// ...\nelse;\n// ...\n"))))),(0,o.kt)("p",null,"To recap, we have learned how to separate conditionally executed cases in our code into\ndedicated if statements. This allows us to choose what code gets run depending on various\nvalues in our program. Now that we have the basic structure of our if-else statement,\nwe can see how to finish our program by creating the boolean condition."),(0,o.kt)("h2",{id:"boolean-expressions"},"Boolean expressions"),(0,o.kt)("p",null,"Inside the parenthesis of an ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," statement is the ",(0,o.kt)("strong",{parentName:"p"},"boolean expression"),", i.e. an expression\nthat evaluates to either ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),". C++ provides several new operators that allow\nus to form such an expression."),(0,o.kt)("h3",{id:"boolean-operators"},"Boolean operators"),(0,o.kt)("p",null,"Below is a table that shows some of the ",(0,o.kt)("strong",{parentName:"p"},"boolean operators")," available in C++. A boolean operator\nis one that returns a boolean ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"false")," based on its input(s).\nThey are like the other mathematical operators you've seen in previous lessons, but instead\nof evaluating to a number like ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),", they evaluate to a ",(0,o.kt)("inlineCode",{parentName:"p"},"bool")," (",(0,o.kt)("inlineCode",{parentName:"p"},"true"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"false"),")."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"C++ operator"),(0,o.kt)("th",{parentName:"tr",align:null},"Math equivalent"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"a == b")),(0,o.kt)("td",{parentName:"tr",align:null},"a ",(0,o.kt)("strong",{parentName:"td"},"=")," b"),(0,o.kt)("td",{parentName:"tr",align:null},"Is ",(0,o.kt)("inlineCode",{parentName:"td"},"a")," equal to ",(0,o.kt)("inlineCode",{parentName:"td"},"b"),"?")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"a != b")),(0,o.kt)("td",{parentName:"tr",align:null},"a \u2260 b"),(0,o.kt)("td",{parentName:"tr",align:null},"Is ",(0,o.kt)("inlineCode",{parentName:"td"},"a")," not equal to ",(0,o.kt)("inlineCode",{parentName:"td"},"b"),"?")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"a > b")),(0,o.kt)("td",{parentName:"tr",align:null},"a ",(0,o.kt)("strong",{parentName:"td"},">")," b"),(0,o.kt)("td",{parentName:"tr",align:null},"Is ",(0,o.kt)("inlineCode",{parentName:"td"},"a")," strictly greater than ",(0,o.kt)("inlineCode",{parentName:"td"},"b"),"?")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"a >= b")),(0,o.kt)("td",{parentName:"tr",align:null},"a \u2265 b"),(0,o.kt)("td",{parentName:"tr",align:null},"Is ",(0,o.kt)("inlineCode",{parentName:"td"},"a")," greater than or equal to ",(0,o.kt)("inlineCode",{parentName:"td"},"b"),"?")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"a < b")),(0,o.kt)("td",{parentName:"tr",align:null},"a ",(0,o.kt)("strong",{parentName:"td"},"<")," b"),(0,o.kt)("td",{parentName:"tr",align:null},"Is ",(0,o.kt)("inlineCode",{parentName:"td"},"a")," strictly less than ",(0,o.kt)("inlineCode",{parentName:"td"},"b"),"?")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"a <= b")),(0,o.kt)("td",{parentName:"tr",align:null},"a \u2264 b"),(0,o.kt)("td",{parentName:"tr",align:null},"Is ",(0,o.kt)("inlineCode",{parentName:"td"},"a")," less than or equal to ",(0,o.kt)("inlineCode",{parentName:"td"},"b"),"?")))),(0,o.kt)("h4",{id:"equality-operators"},"Equality operators"),(0,o.kt)("p",null,"The first two rows of our table ",(0,o.kt)("inlineCode",{parentName:"p"},"==")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"!=")," make up the ",(0,o.kt)("strong",{parentName:"p"},"equality operators"),".\nThese two operators allow us to check if two values are the same.\nThe equality operators work on most C++ types, including numbers, strings, bools, and more."),(0,o.kt)("admonition",{type:"danger"},(0,o.kt)("p",{parentName:"admonition"},"A single ",(0,o.kt)("inlineCode",{parentName:"p"},"=")," is different from a double ",(0,o.kt)("inlineCode",{parentName:"p"},"=="),". The single ",(0,o.kt)("inlineCode",{parentName:"p"},"=")," is the ",(0,o.kt)("strong",{parentName:"p"},"assignment operator"),", such as when you create or change a variable.\nThe double ",(0,o.kt)("inlineCode",{parentName:"p"},"==")," is the ",(0,o.kt)("strong",{parentName:"p"},"equality operator"),", used when you want to check if two variables have the same value."),(0,o.kt)("p",{parentName:"admonition"},"So inside an ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," statement's condition, when you want to check for equality:"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"\u2714 ",(0,o.kt)("inlineCode",{parentName:"li"},"if (a == b)")),(0,o.kt)("li",{parentName:"ul"},"\u274c ",(0,o.kt)("inlineCode",{parentName:"li"},"if (a = b)")))),(0,o.kt)("h4",{id:"relational-operators"},"Relational operators"),(0,o.kt)("p",null,"The next four rows of our table make up the ",(0,o.kt)("strong",{parentName:"p"},"relational operators"),".\nThese two operators allow us to compare two values positionally (such as on a number line\nor alphabetically).\nThe relational operators work on some C++ types, like numbers and strings; however,\nmany other types that we have not covered yet cannot be compared like this."),(0,o.kt)("p",null,"We now know enough to get the first version of our program functioning. As a reminder,\nwe need to make a condition that checks whether the user's age is greater than\nor equal to 18. Using the table above, the closest match is ",(0,o.kt)("inlineCode",{parentName:"p"},"age >= 18"),".\nNow we can fill in our ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," statement:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83d\udd39 Driver\'s License Oracle 2000"',title:'"\ud83d\udd39',"Driver's":!0,License:!0,Oracle:!0,'2000"':!0},'#include <iostream>\n\nint main()\n{\n    std::cout << "Welcome to the Driver\'s License Oracle 2000\\n";\n    std::cout << "Please enter your year of birth: ";\n\n    int yearOfBirth;\n    std::cin >> yearOfBirth;\n\n    // Year 2022 at the moment of writing this lesson\n    int age = 2022 - yearOfBirth;\n\n    // highlight-next-line\n    if (age >= 18)\n    {\n        std::cout << "You can legally get a driver\'s license\\n";\n    }\n    else\n    {\n        std::cout << "You cannot legally get a driver\'s license\\n";\n    }\n}\n')),(0,o.kt)("p",null,"As a bonus challenge, try to form three other equivalent formulations of ",(0,o.kt)("inlineCode",{parentName:"p"},"age >= 18"),", using the other remaining relational operators for each one."),(0,o.kt)("h3",{id:"compound-boolean-expressions"},"Compound boolean expressions"),(0,o.kt)("p",null,"You can transform and combine boolean expressions by what are called the ",(0,o.kt)("strong",{parentName:"p"},"logical operators"),".\nThese are a subset of the boolean operators initially introduced above, but they are intended to take\nboolean value(s) as input. "),(0,o.kt)("p",null,"C++ supports two equivalent forms of these operators, a textual version\nand a symbolic version. While the symbolic representation is more common in the wild, you may find\nthe textual representation to be easier to understand and remember. You can use whichever you like\nbest, but try to be consistent!"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"C++ operator"),(0,o.kt)("th",{parentName:"tr",align:null},"Alternative representation"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"a and b")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"a && b")),(0,o.kt)("td",{parentName:"tr",align:null},"Are ",(0,o.kt)("strong",{parentName:"td"},"both")," ",(0,o.kt)("inlineCode",{parentName:"td"},"a")," AND ",(0,o.kt)("inlineCode",{parentName:"td"},"b")," true?")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"a or b")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("code",null,"a ","|","|","  b")),(0,o.kt)("td",{parentName:"tr",align:null},"Is ",(0,o.kt)("strong",{parentName:"td"},"either")," ",(0,o.kt)("inlineCode",{parentName:"td"},"a")," OR ",(0,o.kt)("inlineCode",{parentName:"td"},"b")," true?")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"not c")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"!c")),(0,o.kt)("td",{parentName:"tr",align:null},"Is ",(0,o.kt)("inlineCode",{parentName:"td"},"c")," false?")))),(0,o.kt)("h4",{id:"logical-and-operator"},"Logical AND operator"),(0,o.kt)("p",null,"The logical AND operator ",(0,o.kt)("inlineCode",{parentName:"p"},"and"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"&&")," takes two boolean inputs and returns ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," if and only if\nboth of its inputs are ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),". It's best to use this when you want to check if multiple conditions are\nall true, or whether multiple conditions are ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," (by also using the negation operator)."),(0,o.kt)("p",null,"For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"false && true")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),", while ",(0,o.kt)("inlineCode",{parentName:"p"},"true and true")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,o.kt)("h4",{id:"logical-or-operator"},"Logical OR operator"),(0,o.kt)("p",null,"Similar to AND, the logical OR operator ",(0,o.kt)("inlineCode",{parentName:"p"},"or"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"||")," takes two boolean inputs and returns ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," if\none or both of its inputs are ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),". It's best to use this when you want to check if any of multiple\nconditions are true, or if one variable is one of many possibilites. "),(0,o.kt)("p",null,"For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"false or false")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),", while ",(0,o.kt)("inlineCode",{parentName:"p"},"false || true")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"true")),(0,o.kt)("h4",{id:"logical-not-operator"},"Logical NOT operator"),(0,o.kt)("p",null,"Pay close attention to the last row in the above table; ",(0,o.kt)("inlineCode",{parentName:"p"},"not"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"!")," is also known as the ",(0,o.kt)("strong",{parentName:"p"},"logical negation operator"),".\nThis operator will flip the truth value of a ",(0,o.kt)("em",{parentName:"p"},"single")," boolean input. So in the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"!c"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," is\na boolean ( ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"false")," ), and the ",(0,o.kt)("inlineCode",{parentName:"p"},"!")," negation operator will turn ",(0,o.kt)("inlineCode",{parentName:"p"},"true\u2192false")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"false\u2192true"),".\nThis is equivalent to asking whether ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),". This operator is useful when you want\nto check whether some condition does not hold."),(0,o.kt)("p",null,"For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"!(a == b)")," is equivalent to ",(0,o.kt)("inlineCode",{parentName:"p"},"a != b"),".\nLikewise, ",(0,o.kt)("inlineCode",{parentName:"p"},"not (a <= b)")," is equivalent to ",(0,o.kt)("inlineCode",{parentName:"p"},"a > b"),".\nTake note of how parentheses are used here to evaluate the inner expression first before logically\nnegating it."),(0,o.kt)("h4",{id:"upgrading-the-oracle"},"Upgrading the Oracle"),(0,o.kt)("p",null,"The state has passed new regulations and now we must upgrade our Oracle program to comply.\nThe new law stipulates a maximum age for driver's licenses \u2014 ",(0,o.kt)("u",null,"those 65 years and older are\nno longer allowed to operate a motor vehicle"),"."),(0,o.kt)("p",null,"We need to expand on our boolean condition to abide by this new requirement. Currently,\n",(0,o.kt)("inlineCode",{parentName:"p"},"age >= 18")," sets the ",(0,o.kt)("em",{parentName:"p"},"lower bound")," for the range of acceptable values.\nWe are missing something that sets the ",(0,o.kt)("em",{parentName:"p"},"upper bound"),", which should be 65.\nA boolean expression that checks if the age is less than 65 could look like ",(0,o.kt)("inlineCode",{parentName:"p"},"age < 65"),".\nNote that we use ",(0,o.kt)("inlineCode",{parentName:"p"},"<")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"<=")," because 65 year olds are banned from driving."),(0,o.kt)("p",null,"Now we have ",(0,o.kt)("inlineCode",{parentName:"p"},"age >= 18")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"age < 65"),", which must be combined in some way.\nWe need to somehow specify that BOTH must be true \u2014 the person must be\n18 or older AND younger than 65 to get a driver's license. "),(0,o.kt)("p",null,"Looking back at the table in ",(0,o.kt)("a",{parentName:"p",href:"#compound-boolean-expressions"},"Compound boolean expressions"),",\nwe can see that the ",(0,o.kt)("inlineCode",{parentName:"p"},"and"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"&&")," operator fits this situation best.\nWe can write this compound condition like ",(0,o.kt)("inlineCode",{parentName:"p"},"age >= 18 and age < 65"),". Note\nthat the left/right order here does not matter, meaning that\n",(0,o.kt)("inlineCode",{parentName:"p"},"age < 65 and age >= 18")," is an equivalent condition."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83d\udd39 Driver\'s License Oracle 3000"',title:'"\ud83d\udd39',"Driver's":!0,License:!0,Oracle:!0,'3000"':!0},'#include <iostream>\n\nint main()\n{\n    std::cout << "Welcome to the Driver\'s License Oracle 3000\\n";\n    std::cout << "Please enter your year of birth: ";\n\n    int yearOfBirth;\n    std::cin >> yearOfBirth;\n\n    // Year 2022 at the moment of writing this lesson\n    int age = 2022 - yearOfBirth;\n\n    // highlight-next-line\n    if (age >= 18 and age < 65)\n    {\n        std::cout << "You can legally get a driver\'s license\\n";\n    }\n    else\n    {\n        std::cout << "You cannot legally get a driver\'s license\\n";\n    }\n}\n')),(0,o.kt)("admonition",{title:"Chaining equality or relational operators",type:"danger"},(0,o.kt)("p",{parentName:"admonition"},"You may be tempted to rewrite the above compound condition like ",(0,o.kt)("inlineCode",{parentName:"p"},"18 <= age < 65"),".\nHowever, this ",(0,o.kt)("strong",{parentName:"p"},"will not work"),". While it will compile, it will result in incorrect\nbehavior as it will always evaluate to ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),". "),(0,o.kt)("p",{parentName:"admonition"},"The same incorrect behavior also occurs with the equality operators.\nFor example, ",(0,o.kt)("inlineCode",{parentName:"p"},"age1 == age2 == 18")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"age1 != age2 != 35")," will both behave similarly\nto the above example, either always returning false or always returning true."),(0,o.kt)("p",{parentName:"admonition"},"Never attempt to chain equality or relational operators.\nAlways use the logical operators ",(0,o.kt)("inlineCode",{parentName:"p"},"and"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"&&")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"or"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"||")," to combine boolean expressions.\nFor more information as to the reasoning behind this,\nsee ",(0,o.kt)("a",{parentName:"p",href:"/learn/course/basics/conditions/booleans/#intbool-conversions"},"Booleans \xbb int\u2194bool conversions"),".")),(0,o.kt)("h3",{id:"order-of-operations"},"Order of Operations"),(0,o.kt)("p",null,'Like the mathematical operators, the boolean operators also have their own priority schedule\nthey strictly adhere to. Similar to "PEMDAS", those inside parentheses always gets evaluated\nfirst, and the other operators are computed according to their priorities listed below.\nHighest priority is on top.'),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Operator"),(0,o.kt)("th",{parentName:"tr",align:null},"Name"),(0,o.kt)("th",{parentName:"tr",align:null},"Associativity"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"!")," ",(0,o.kt)("inlineCode",{parentName:"td"},"not")),(0,o.kt)("td",{parentName:"tr",align:null},"Logical NOT"),(0,o.kt)("td",{parentName:"tr",align:null},"Right-to-left \ud83e\udc60")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"*")," ",(0,o.kt)("inlineCode",{parentName:"td"},"/")," ",(0,o.kt)("inlineCode",{parentName:"td"},"%")),(0,o.kt)("td",{parentName:"tr",align:null},"Multiplication/Division"),(0,o.kt)("td",{parentName:"tr",align:null},"Left-to-right \ud83e\udc62")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"+")," ",(0,o.kt)("inlineCode",{parentName:"td"},"-")),(0,o.kt)("td",{parentName:"tr",align:null},"Addition/Substraction"),(0,o.kt)("td",{parentName:"tr",align:null},"Left-to-right \ud83e\udc62")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"<")," ",(0,o.kt)("inlineCode",{parentName:"td"},"<=")," ",(0,o.kt)("inlineCode",{parentName:"td"},">")," ",(0,o.kt)("inlineCode",{parentName:"td"},">=")),(0,o.kt)("td",{parentName:"tr",align:null},"Relational operators"),(0,o.kt)("td",{parentName:"tr",align:null},"Left-to-right \ud83e\udc62")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"==")," ",(0,o.kt)("inlineCode",{parentName:"td"},"!=")),(0,o.kt)("td",{parentName:"tr",align:null},"Equality operators"),(0,o.kt)("td",{parentName:"tr",align:null},"Left-to-right \ud83e\udc62")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"&&")," ",(0,o.kt)("inlineCode",{parentName:"td"},"and")),(0,o.kt)("td",{parentName:"tr",align:null},"Logical AND"),(0,o.kt)("td",{parentName:"tr",align:null},"Left-to-right \ud83e\udc62")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("code",null,"|","|")," ",(0,o.kt)("inlineCode",{parentName:"td"},"or")),(0,o.kt)("td",{parentName:"tr",align:null},"Logical OR"),(0,o.kt)("td",{parentName:"tr",align:null},"Left-to-right \ud83e\udc62")))),(0,o.kt)("p",null,"Let's use this to analyze some examples."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83d\udd39 Order of Operations showcase"',title:'"\ud83d\udd39',Order:!0,of:!0,Operations:!0,'showcase"':!0},"a > 10 and a < 100 or a == 150\n// equivalent to\n(a > 10 and a < 100) or a == 150\n\na * 4 == b + 5\n// equivalent to\n(a * 4) == (b + 5)\n\nnot a or b < 3701\n// equivalent to\n(not a) or (b < 3701)\n\nnot a != false\n// equivalent to\n(not a) != false\n")),(0,o.kt)("admonition",{title:"Use parentheses for disambiguation",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"It's best practice to not rely on the implicit rules of operator precedence too much.\nIt can be hard for programmers to remember all of the rules about which operator gets\nevaluated first, so writing too much code that depends on these rules can make it\nharder to read and understand. If you intend for a subexpression to be evaluated first,\nit's a good idea to put it in parentheses."),(0,o.kt)("p",{parentName:"admonition"},"So, instead of writing ",(0,o.kt)("inlineCode",{parentName:"p"},"a and b and c or a and not b"),", consider doing ",(0,o.kt)("inlineCode",{parentName:"p"},"(a and b and c) or (a and not b)")," instead.")))}m.isMDXComponent=!0},56693:(e,t,n)=>{n.d(t,{ZP:()=>i});var a=n(87462),o=(n(67294),n(3905));const r={toc:[]};function i(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},r,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Note, this article is not finished! You can help by editing this doc page.")))}i.isMDXComponent=!0},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),o=n(86010);const r="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(r,i),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>w});var a=n(87462),o=n(67294),r=n(86010),i=n(12466),l=n(76775),s=n(91980),p=n(67392),d=n(50012);function u(e){return function(e){return o.Children.map(e,(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:o}}=e;return{value:t,label:n,attributes:a,default:o}}))}function c(e){const{values:t,children:n}=e;return(0,o.useMemo)((()=>{const e=t??u(n);return function(e){const t=(0,p.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,l.k6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s._X)(r),(0,o.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(a.location.search);t.set(r,e),a.replace({...a.location,search:t.toString()})}),[r,a])]}function k(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,r=c(e),[i,l]=(0,o.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:r}))),[s,p]=h({queryString:n,groupId:a}),[u,k]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,r]=(0,d.Nk)(n);return[a,(0,o.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:a}),g=(()=>{const e=s??u;return m({value:e,tabValues:r})?e:null})();(0,o.useLayoutEffect)((()=>{g&&l(g)}),[g]);return{selectedValue:i,selectValue:(0,o.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),p(e),k(e)}),[p,k,r]),tabValues:r}}var g=n(72389);const b="tabList__CuJ",N="tabItem_LNqP";function f(e){let{className:t,block:n,selectedValue:l,selectValue:s,tabValues:p}=e;const d=[],{blockElementScrollPositionUntilNextRender:u}=(0,i.o5)(),c=e=>{const t=e.currentTarget,n=d.indexOf(t),a=p[n].value;a!==l&&(u(t),s(a))},m=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=d.indexOf(e.currentTarget)+1;t=d[n]??d[0];break}case"ArrowLeft":{const n=d.indexOf(e.currentTarget)-1;t=d[n]??d[d.length-1];break}}t?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},t)},p.map((e=>{let{value:t,label:n,attributes:i}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>d.push(e),onKeyDown:m,onClick:c},i,{className:(0,r.Z)("tabs__item",N,i?.className,{"tabs__item--active":l===t})}),n??t)})))}function y(e){let{lazy:t,children:n,selectedValue:a}=e;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===a));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function v(e){const t=k(e);return o.createElement("div",{className:(0,r.Z)("tabs-container",b)},o.createElement(f,(0,a.Z)({},e,t)),o.createElement(y,(0,a.Z)({},e,t)))}function w(e){const t=(0,g.Z)();return o.createElement(v,(0,a.Z)({key:String(t)},e))}}}]);