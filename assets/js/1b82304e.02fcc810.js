"use strict";(self.webpackChunkcpp_lang_net=self.webpackChunkcpp_lang_net||[]).push([[861],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=s(n),m=i,d=u["".concat(c,".").concat(m)]||u[m]||h[m]||r;return n?a.createElement(d,l(l({ref:t},p),{},{components:n})):a.createElement(d,l({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8210:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var a=n(87462),i=(n(67294),n(3905));const r={title:"Polymorphism",description:"Lesson: polymorphism basics in C++"},l="Polymorphism",o={unversionedId:"course/basics/polymorphism",id:"course/basics/polymorphism",title:"Polymorphism",description:"Lesson: polymorphism basics in C++",source:"@site/content/learn/course/basics/polymorphism.mdx",sourceDirName:"course/basics",slug:"/course/basics/polymorphism",permalink:"/CppLangNet/learn/course/basics/polymorphism",draft:!1,editUrl:"https://github.com/Cpp4You/CppLangNet/edit/main/content/learn/course/basics/polymorphism.mdx",tags:[],version:"current",frontMatter:{title:"Polymorphism",description:"Lesson: polymorphism basics in C++"},sidebar:"defaultSidebar",previous:{title:"Special methods",permalink:"/CppLangNet/learn/course/basics/methods/special-methods"},next:{title:"Aliases",permalink:"/CppLangNet/learn/course/basics/aliases"}},c={},s=[{value:"Motivation",id:"motivation",level:2},{value:"Naive implementation",id:"naive-implementation",level:3},{value:"Virtual functions",id:"virtual-functions",level:2},{value:"Static dispatch",id:"static-dispatch",level:3},{value:"Dynamic dispatch",id:"dynamic-dispatch",level:3},{value:"Using virtual functions",id:"using-virtual-functions",level:3},{value:"Limitations",id:"limitations",level:3}],p={toc:s};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"polymorphism"},"Polymorphism"),(0,i.kt)("p",null,"In this lesson we'll learn how to execute different logic depending on the type of an object, that is, we'll learn about polymorphism."),(0,i.kt)("h2",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,"When creating hierarchies of structures, one of the main problems that arise is that different types of objects handle the same task differently.\nFor example, when it comes to vehicles, the way a car accelerates is different from that of an airplane.\nThis can make it difficult to write code that can handle different types of vehicles in a uniform way."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83e\udd14 Different logic for different types of vehicles"',title:'"\ud83e\udd14',Different:!0,logic:!0,for:!0,different:!0,types:!0,of:!0,'vehicles"':!0},'struct Vehicle\n{\n    double speed;\n    void accelerate() {\n        std::cout << "Burning fuel\\n"; // nothing too specific\n    }\n};\n\nstruct Car\n    : Vehicle\n{\n    void accelerate() {\n        std::cout << "Engaging the engine\\n";\n        std::cout << "Pressing the gas pedal\\n";\n    }\n};\n\nstruct Airplane\n    : Vehicle\n{\n    void accelerate() {\n        std::cout << "Engaging multiple engines\\n";\n        std::cout << "Increasing the throttle\\n";\n    }\n};\n')),(0,i.kt)("p",null,"We'll use a game as an example. Let's assume the player can use different kinds of vehicles. It's important to handle the player's input\nin a consistent way, regardless of the type of vehicle player is currently using. For example, when the player presses the ",(0,i.kt)("inlineCode",{parentName:"p"},"W")," key,\nit should accelerate. However, since we want each type of vehicle to run different logic to accelerate,\ndifferent implementations of the method are provided (see the code above)."),(0,i.kt)("h3",{id:"naive-implementation"},"Naive implementation"),(0,i.kt)("script",{src:"https://asciinema.org/a/14.js",id:"asciicast-14",async:!0}),(0,i.kt)("p",null,"One could write a function that handles the player's input and calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"accelerate()")," method of the vehicle:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// prism-push-types:Vehicle\nvoid handleAccelerateButton(Vehicle const& vehicle) {\n    std::cout << "Handling the accelerate button...\\n";\n    vehicle.accelerate();\n}\n')),(0,i.kt)("p",null,"This however, will call the ",(0,i.kt)("inlineCode",{parentName:"p"},"accelerate()")," method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Vehicle")," base class, which does not have the specific behavior\nfor the actual type of vehicle. This means that the player's vehicle will not accelerate as expected:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83d\udca2 Unexpected behavior"',title:'"\ud83d\udca2',Unexpected:!0,'behavior"':!0},"// prism-push-types:Car,Airplane\nCar car;\nAirplane airplane;\n\nhandleAccelerateButton(car);\nhandleAccelerateButton(airplane);\n")),(0,i.kt)("h2",{id:"virtual-functions"},"Virtual functions"),(0,i.kt)("p",null,"The solution to this problem is to mark the ",(0,i.kt)("inlineCode",{parentName:"p"},"accelerate()")," as virtual ",(0,i.kt)("strong",{parentName:"p"},"in the base class"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Vehicle\n{\n    double speed;\n    // highlight-next-line\n    virtual void accelerate() {\n        std::cout << "Burning fuel\\n"; // nothing too specific\n    }\n};\n')),(0,i.kt)("p",null,"With the previous code, we experienced what is called a ",(0,i.kt)("strong",{parentName:"p"},"static dispatch")," that resulted in a ",(0,i.kt)("strong",{parentName:"p"},"method shadowing"),".\nThis happens when a derived class introduces its own function with the same name as in the base class\nand the base class' function is ",(0,i.kt)("strong",{parentName:"p"},"not")," marked as ",(0,i.kt)("inlineCode",{parentName:"p"},"virtual"),"."),(0,i.kt)("p",null,"In the earlier example, the type of the object on which we called the ",(0,i.kt)("inlineCode",{parentName:"p"},"accelerate()")," as seen by the compiler was ",(0,i.kt)("inlineCode",{parentName:"p"},"Vehicle"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"void handleAccelerateButton(Vehicle const& vehicle)\n")),(0,i.kt)("p",null,"To call the proper implementation, the program has to first determine the exact type of the object, which requires a ",(0,i.kt)("strong",{parentName:"p"},"dynamic dispatch"),".\nThis is done by marking the ",(0,i.kt)("inlineCode",{parentName:"p"},"accelerate()")," method as ",(0,i.kt)("inlineCode",{parentName:"p"},"virtual")," in the base structure."),(0,i.kt)("h3",{id:"static-dispatch"},"Static dispatch"),(0,i.kt)("p",null,"During a ",(0,i.kt)("strong",{parentName:"p"},"static dispatch")," (default one), the compiler determines which function to call at compile time, based on the type of an object\nprovided at the call site."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83d\udca1 Static dispatch"',title:'"\ud83d\udca1',Static:!0,'dispatch"':!0},"// prism-push-types:Airplane\nAirplane airplane;\nairplane.accelerate();\n")),(0,i.kt)("h3",{id:"dynamic-dispatch"},"Dynamic dispatch"),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"dynamic dispatch")," causes the compiler to determine which function to call at run time, based on the actual type of the object.\nThis comes at a small performance cost, but don't worry about it too much for now."),(0,i.kt)("p",null,"Assuming the ",(0,i.kt)("inlineCode",{parentName:"p"},"accelerate()")," method is marked as ",(0,i.kt)("inlineCode",{parentName:"p"},"virtual")," in the base class, the following code results in a dynamic dispatch:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="\ud83d\udca1 Dynamic dispatch"',title:'"\ud83d\udca1',Dynamic:!0,'dispatch"':!0},"// prism-push-types:Airplane,Vehicle\nAirplane airplane;\n\n// access the accelerate() method through a reference to the base class\nVehicle& vehicle = airplane;\nvehicle.accelerate();\n")),(0,i.kt)("h3",{id:"using-virtual-functions"},"Using virtual functions"),(0,i.kt)("h3",{id:"limitations"},"Limitations"))}h.isMDXComponent=!0}}]);